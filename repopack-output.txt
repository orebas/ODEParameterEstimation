================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-08-07T01:22:08.221Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.github/
  workflows/
    CI.yml
    CompatHelper.yml
    TagBot.yml
  dependabot.yml
benchmark/
  benchmarks.jl
docs/
  src/
    index.md
  make.jl
  Project.toml
examples/
  all_examples.jl
  daisy_only.jl
  main_tests.jl
  simple.jl
  trivial.jl
src/
  bary_derivs.jl
  equation_solvers.jl
  ODEParameterEstimation.jl
  sample_data.jl
  SharedUtils.jl
  test_utils.jl
  utils.jl
test/
  Project.toml
  runtests.jl
testdir/
  1000x/
    1000x.jl
  main_tests.jl
.gitignore
LICENSE
Project.toml
README.md
TODO

================================================================
Repository Files
================================================================


================
File: Project.toml
================
name = "ODEParameterEstimation"
uuid = "482fc905-5656-4c69-b8fe-7a66cd0f77b3"
authors = ["Oren Bassik <orebas@yahoo.com> and contributors"]
version = "1.0.0-DEV"

[deps]
BaryRational = "91aaffc3-5777-4842-85b7-5d3d5d6a3494"
ForwardDiff = "f6369f11-7733-5829-9624-2563aa707210"
HomotopyContinuation = "f213a82b-91d6-5c5d-acf7-10f1c761b327"
LinearAlgebra = "37e2e46d-f89d-539d-b4ee-838fcccc9c8e"
ModelingToolkit = "961ee093-0014-501f-94e3-6117800e7a78"
OrderedCollections = "bac558e1-5e72-5ebc-8fee-abe8a469f55d"
OrdinaryDiffEq = "1dea7af3-3e70-54e6-95c3-0bf5283fa5ed"
PrecompileTools = "aea7be01-6a6a-4083-8856-8a6e6704d82a"
Random = "9a3f8284-a2c9-5f02-9a11-845980a1fd5c"
Suppressor = "fd094767-a336-5f1f-9728-57cf17d0bbfb"
TaylorDiff = "b36ab563-344f-407b-a36a-4f200bebf99c"

[compat]
#OrdinaryDiffEq = "6.80.1"
#Random = "1.11.0"
#TaylorDiff = "0.2.1"
julia = "1.10"

[extras]
Test = "8dfed614-e22c-5e08-85e1-65c5234f0b40"

[targets]
test = ["Test"]

================
File: README.md
================
# ODEParameterEstimation

[![Build Status](https://github.com/orebas/ODEParameterEstimation.jl/actions/workflows/CI.yml/badge.svg?branch=main)](https://github.com/orebas/ODEParameterEstimation.jl/actions/workflows/CI.yml?query=branch%3Amain)

================
File: TODO
================
rewrite output:  
	show which vars are globally unident
	for each output set, show map from var to value, including what was used for global subst
	show error (to sample data)
	optional:  compare each output param value to input param value if supplied


implement multiple point method
produce overdetermind equations from multiple point
add tests against SI.jl (local vs structural identifiability)
test  all examples from SI.jl, and whatever other sources are available
add newton or other polisher to increase precision (perhaps using SCIML optimizers)
add support for big float, make sure we support complex valued ODEs, and in general make more type agnostic
    -may not work because HomotopyContinuation doesn't support most of these
test solving with monodromy

add tests with longer time periods, and oscillatory ODEs
check max derivative calculuation
add tests for stiff diffeqs, and support stiff diffeqs generally


================
File: docs/Project.toml
================
[deps]
Documenter = "e30172f5-a6a5-5a46-863b-614d45cd2de4"
ODEParameterEstimation = "482fc905-5656-4c69-b8fe-7a66cd0f77b3"

================
File: docs/make.jl
================
using ODEParameterEstimation
using Documenter

DocMeta.setdocmeta!(ODEParameterEstimation, :DocTestSetup, :(using ODEParameterEstimation); recursive=true)

makedocs(;
    modules=[ODEParameterEstimation],
    authors="Oren Bassik <orebas@yahoo.com> and contributors",
    sitename="ODEParameterEstimation.jl",
    format=Documenter.HTML(;
        edit_link="main",
        assets=String[],
    ),
    pages=[
        "Home" => "index.md",
    ],
)

================
File: examples/all_examples.jl
================
using ODEParameterEstimation
using ModelingToolkit
using DifferentialEquations
#using SharedUtils

function biohydrogenation()
    @parameters k5 k6 k7 k8 k9 k10
    @variables t x4(t) x5(t) x6(t) x7(t) y1(t) y2(t)
    D = Differential(t)
    
    states = [x4, x5, x6, x7]
    parameters = [k5, k6, k7, k8, k9, k10]
    equations = [
        D(x4) ~ -k5 * x4 / (k6 + x4),
        D(x5) ~ k5 * x4 / (k6 + x4) - k7 * x5 / (k8 + x5 + x6),
        D(x6) ~ k7 * x5 / (k8 + x5 + x6) - k9 * x6 * (k10 - x6) / k10,
        D(x7) ~ k9 * x6 * (k10 - x6) / k10
    ]
    measured_quantities = [y1 ~ x4, y2 ~ x5]
    
    model, mq = create_ode_system("BioHydrogenation", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "BioHydrogenation",
        model,
        mq,
        nothing,
        nothing,
        [0.143, 0.286, 0.429, 0.571, 0.714, 0.857],
        [0.2, 0.4, 0.6, 0.8],
        1
    )
end

function crauste()
    @parameters mu_N mu_EE mu_LE mu_LL mu_M mu_P mu_PE mu_PL delta_NE delta_EL delta_LM rho_E rho_P
    @variables t N(t) E(t) S(t) M(t) P(t) y1(t) y2(t) y3(t) y4(t)
    D = Differential(t)
    
    states = [N, E, S, M, P]
    parameters = [mu_N, mu_EE, mu_LE, mu_LL, mu_M, mu_P, mu_PE, mu_PL, delta_NE, delta_EL, delta_LM, rho_E, rho_P]
    equations = [
        D(N) ~ -N * mu_N - N * P * delta_NE,
        D(E) ~ N * P * delta_NE - E^2 * mu_EE - E * delta_EL + E * P * rho_E,
        D(S) ~ S * delta_EL - S * delta_LM - S^2 * mu_LL - E * S * mu_LE,
        D(M) ~ S * delta_LM - mu_M * M,
        D(P) ~ P^2 * rho_P - P * mu_P - E * P * mu_PE - S * P * mu_PL
    ]
    measured_quantities = [y1 ~ N, y2 ~ E, y3 ~ S + M, y4 ~ P]
    
    model, mq = create_ode_system("Crauste", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "Crauste",
        model,
        mq,
        nothing,
        nothing,
        [0.071, 0.143, 0.214, 0.286, 0.357, 0.429, 0.5, 0.571, 0.643, 0.714, 0.786, 0.857, 0.929],
        [0.167, 0.333, 0.5, 0.667, 0.833],
        0
    )
end

function daisy_ex3()
    @parameters p1 p3 p4 p6 p7
    @variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
    D = Differential(t)
    
    states = [x1, x2, x3, u0]
    parameters = [p1, p3, p4, p6, p7]
    equations = [
        D(x1) ~ -1.0 * p1 * x1 + x2 + u0,
        D(x2) ~ p3 * x1 - p4 * x2 + x3,
        D(x3) ~ p6 * x1 - p7 * x3,
        D(u0) ~ 1.0
    ]
    measured_quantities = [y1 ~ x1, y2 ~ u0]
    
    model, mq = create_ode_system("DAISY_ex3", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "DAISY_ex3",
        model,
        mq,
        nothing,
        nothing,
        [0.167, 0.333, 0.5, 0.667, 0.833],
        [0.2, 0.4, 0.6, 0.8],
        0
    )
end

function daisy_mamil3()
    @parameters a12 a13 a21 a31 a01
    @variables t x1(t) x2(t) x3(t) y1(t) y2(t)
    D = Differential(t)
    
    states = [x1, x2, x3]
    parameters = [a12, a13, a21, a31, a01]
    equations = [
        D(x1) ~ -(a21 + a31 + a01) * x1 + a12 * x2 + a13 * x3,
        D(x2) ~ a21 * x1 - a12 * x2,
        D(x3) ~ a31 * x1 - a13 * x3
    ]
    measured_quantities = [y1 ~ x1, y2 ~ x2]
    
    model, mq = create_ode_system("DAISY_mamil3", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "DAISY_mamil3",
        model,
        mq,
        nothing,
        nothing,
        [0.167, 0.333, 0.5, 0.667, 0.833],
        [0.25, 0.5, 0.75],
        0
    )
end

function daisy_mamil4()
    @parameters k01 k12 k13 k14 k21 k31 k41
    @variables t x1(t) x2(t) x3(t) x4(t) y1(t) y2(t) y3(t)
    D = Differential(t)
    
    states = [x1, x2, x3, x4]
    parameters = [k01, k12, k13, k14, k21, k31, k41]
    equations = [
        D(x1) ~ -k01 * x1 + k12 * x2 + k13 * x3 + k14 * x4 - k21 * x1 - k31 * x1 - k41 * x1,
        D(x2) ~ -k12 * x2 + k21 * x1,
        D(x3) ~ -k13 * x3 + k31 * x1,
        D(x4) ~ -k14 * x4 + k41 * x1
    ]
    measured_quantities = [y1 ~ x1, y2 ~ x2, y3 ~ x3 + x4]
    
    model, mq = create_ode_system("DAISY_mamil4", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "DAISY_mamil4",
        model,
        mq,
        nothing,
        nothing,
        [0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875],
        [0.2, 0.4, 0.6, 0.8],
        0
    )
end

function fitzhugh_nagumo()
    @parameters g a b
    @variables t V(t) R(t) y1(t) y2(t)
    D = Differential(t)
    
    states = [V, R]
    parameters = [g, a, b]
    equations = [
        D(V) ~ g * (V - V^3 / 3 + R),
        D(R) ~ 1 / g * (V - a + b * R)
    ]
    measured_quantities = [y1 ~ V]
    
    model, mq = create_ode_system("fitzhugh-nagumo", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "fitzhugh-nagumo",
        model,
        mq,
        nothing,
        nothing,
        [0.25, 0.5, 0.75],
        [0.333, 0.67],
        0
    )
end

function hiv()
    @parameters lm d beta a k u c q b h
    @variables t x(t) y(t) v(t) w(t) z(t) y1(t) y2(t) y3(t) y4(t)
    D = Differential(t)
    
    states = [x, y, v, w, z]
    parameters = [lm, d, beta, a, k, u, c, q, b, h]
    equations = [
        D(x) ~ lm - d * x - beta * x * v,
        D(y) ~ beta * x * v - a * y,
        D(v) ~ k * y - u * v,
        D(w) ~ c * x * y * w - c * q * y * w - b * w,
        D(z) ~ c * q * y * w - h * z
    ]
    measured_quantities = [y1 ~ w, y2 ~ z, y3 ~ x, y4 ~ y + v]
    
    model, mq = create_ode_system("hiv", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "hiv",
        model,
        mq,
        nothing,
        nothing,
        [0.091, 0.181, 0.273, 0.364, 0.455, 0.545, 0.636, 0.727, 0.818, 0.909],
        [0.167, 0.333, 0.5, 0.667, 0.833],
        0
    )
end

function lotka_volterra()
    @parameters k1 k2 k3
    @variables t r(t) w(t) y1(t)
    D = Differential(t)
    
    states = [r, w]
    parameters = [k1, k2, k3]
    equations = [
        D(r) ~ k1 * r - k2 * r * w,
        D(w) ~ k2 * r * w - k3 * w
    ]
    measured_quantities = [y1 ~ r]
    
    model, mq = create_ode_system("Lotka_Volterra", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "Lotka_Volterra",
        model,
        mq,
        nothing,
        nothing,
        [0.25, 0.5, 0.75],
        [0.333, 0.667],
        0
    )
end

function seir()
    @parameters a b nu
    @variables t S(t) E(t) In(t) N(t) y1(t) y2(t)
    D = Differential(t)
    
    states = [S, E, In, N]
    parameters = [a, b, nu]
    equations = [
        D(S) ~ -b * S * In / N,
        D(E) ~ b * S * In / N - nu * E,
        D(In) ~ nu * E - a * In,
        D(N) ~ 0
    ]
    measured_quantities = [y1 ~ In, y2 ~ N]
    
    model, mq = create_ode_system("SEIR", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "SEIR",
        model,
        mq,
        nothing,
        nothing,
        [0.25, 0.5, 0.75],
        [0.2, 0.4, 0.6, 0.8],
        0
    )
end

function simple()
    @parameters a b
    @variables t x1(t) x2(t) y1(t) y2(t)
    D = Differential(t)
    
    states = [x1, x2]
    parameters = [a, b]
    equations = [
        D(x1) ~ -a * x2,
        D(x2) ~ b * x1
    ]
    measured_quantities = [y1 ~ x1, y2 ~ x2]
    
    model, mq = create_ode_system("simple", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "simple",
        model,
        mq,
        nothing,
        nothing,
        [0.4, 0.8],
        [0.333, 0.667],
        0
    )
end


function sirsforced()
    @parameters b0 b1 g M mu nu
    @variables t i(t) r(t) s(t) x1(t) x2(t) y1(t) y2(t)
    D = Differential(t)
    
    states = [i, r, s, x1, x2]
    parameters = [b0, b1, g, M, mu, nu]
    equations = [
        D(i) ~ b0 * (1.0 + b1 * x1) * i * s - (nu + mu) * i,
        D(r) ~ nu * i - (mu + g) * r,
        D(s) ~ mu - mu * s - b0 * (1.0 + b1 * x1) * i * s + g * r,
        D(x1) ~ -M * x2,
        D(x2) ~ M * x1
    ]
    measured_quantities = [y1 ~ i, y2 ~ r]
    
    model, mq = create_ode_system("sirsforced", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "sirsforced",
        model,
        mq,
        nothing,
        nothing,
        [0.143, 0.286, 0.429, 0.571, 0.714, 0.857],
        [0.167, 0.333, 0.5, 0.667, 0.833],
        3
    )
end

function slowfast()
    @parameters k1 k2 eB
    @variables t xA(t) xB(t) xC(t) eA(t) eC(t) y1(t) y2(t) y3(t) y4(t)
    D = Differential(t)
    
    states = [xA, xB, xC, eA, eC]
    parameters = [k1, k2, eB]
    equations = [
        D(xA) ~ -k1 * xA,
        D(xB) ~ k1 * xA - k2 * xB,
        D(xC) ~ k2 * xB,
        D(eA) ~ 0,
        D(eC) ~ 0
    ]
    measured_quantities = [y1 ~ xC, y2 ~ eA * xA + eB * xB + eC * xC, y3 ~ eA, y4 ~ eC]
    
    model, mq = create_ode_system("slowfast", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "slowfast",
        model,
        mq,
        nothing,
        nothing,
        [0.25, 0.5, 0.75],
        [0.166, 0.333, 0.5, 0.666, 0.833],
        0
    )
end

function substr_test()
    @parameters a b beta
    @variables t x1(t) x2(t) x3(t) y1(t) y2(t) y3(t)
    D = Differential(t)
    
    states = [x1, x2, x3]
    parameters = [a, b, beta]
    equations = [
        D(x1) ~ -a * x2,
        D(x2) ~ b * (x1),
        D(x3) ~ a * b * beta * b * a * x3
    ]
    measured_quantities = [y1 ~ x1, y2 ~ x2, y3 ~ x3]
    
    model, mq = create_ode_system("substr_test", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "substr_test",
        model,
        mq,
        nothing,
        nothing,
        [0.1, 0.2, 0.3],
        [2.0, 3.0, 4.0],
        0
    )
end

function global_unident_test()
    @parameters a b c d
    @variables t x1(t) x2(t) x3(t) y1(t) y2(t)
    D = Differential(t)
    
    states = [x1, x2, x3]
    parameters = [a, b, c, d]
    equations = [
        D(x1) ~ -a * x1,
        D(x2) ~ (b + c) * (x1),
        D(x3) ~ d * x1
    ]
    measured_quantities = [y1 ~ x1, y2 ~ x2]
    
    model, mq = create_ode_system("global_unident_test", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "global_unident_test",
        model,
        mq,
        nothing,
        nothing,
        [0.1, 0.2, 0.3, 0.4],
        [2.0, 3.0, 4.0],
        4
    )
end

function sum_test()
    @parameters a b c
    @variables t x1(t) x2(t) x3(t) y1(t) y2(t)
    D = Differential(t)
    
    states = [x1, x2, x3]
    parameters = [a, b, c]
    equations = [
        D(x1) ~ -a * x1,
        D(x2) ~ b * (x2),
        D(x3) ~ c * (x1 + x2)
    ]
    measured_quantities = [y1 ~ x3]
    
    model, mq = create_ode_system("sum_test", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "sum_test",
        model,
        mq,
        nothing,
        nothing,
        [0.1, 0.2, 0.3],
        [2.0, 3.0, 4.0],
        3
    )
end

function treatment()
    @parameters a b d g nu
    @variables t In(t) N(t) S(t) Tr(t) y1(t) y2(t)
    D = Differential(t)
    
    states = [In, N, S, Tr]
    parameters = [a, b, d, g, nu]
    equations = [
        D(In) ~ b * S * In / N + d * b * S * Tr / N - (a + g) * In,
        D(N) ~ 0,
        D(S) ~ -b * S * In / N - d * b * S * Tr / N,
        D(Tr) ~ g * In - nu * Tr
    ]
    measured_quantities = [y1 ~ Tr, y2 ~ N]
    
    model, mq = create_ode_system("treatment", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "treatment",
        model,
        mq,
        nothing,
        nothing,
        [0.167, 0.333, 0.5, 0.667, 0.833],
        [0.2, 0.4, 0.6, 0.8],
        6
    )
end

function vanderpol()
    @parameters a b
    @variables t x1(t) x2(t) y1(t) y2(t)
    D = Differential(t)
    
    states = [x1, x2]
    parameters = [a, b]
    equations = [
        D(x1) ~ a * x2,
        D(x2) ~ -(x1) - b * (x1^2 - 1) * (x2)
    ]
    measured_quantities = [y1 ~ x1, y2 ~ x2]
    
    model, mq = create_ode_system("vanderpol", states, parameters, equations, measured_quantities)
    
    return ParameterEstimationProblem(
        "vanderpol",
        model,
        mq,
        nothing,
        nothing,
        [0.4, 0.8],
        [0.333, 0.667],
        0
    )
end

function analyze_parameter_estimation_problem(PEP::ParameterEstimationProblem; test_mode = false, showplot = true, run_ode_pe = true)
    if run_ode_pe
        println("Starting model: ", PEP.name)
        res = ODEPEtestwrapper(PEP.model, PEP.measured_quantities, PEP.data_sample, PEP.solver)
        besterror = analyze_estimation_result(PEP, res)
        
        if test_mode
           # @test besterror < 1e-1
        end
    end
end

function varied_estimation_main()
    println("testing")
    time_interval = [-0.5, 0.5]
    datasize = 21
    
    models = [
        simple(),
        substr_test(),
        vanderpol(),
        daisy_mamil3(),
        fitzhugh_nagumo(),
        slowfast(),
        daisy_ex3(),
        sum_test(),
        daisy_mamil4(),
        lotka_volterra(),
        global_unident_test(),
        hiv(),
        seir(),
        biohydrogenation(),
        treatment(),
        crauste(),
        sirsforced()
    ]
    
    for PEP in models
        analyze_parameter_estimation_problem(sample_problem_data(PEP, datasize = datasize, time_interval = time_interval), test_mode = false, showplot = true)
    end
end

varied_estimation_main()

================
File: examples/daisy_only.jl
================
using ODEParameterEstimation
using Test
using ModelingToolkit
using HomotopyContinuation
using DifferentialEquations
using OrderedCollections
#using ParameterEstimation



struct ParameterEstimationProblem
	Name::Any
	model::Any
	measured_quantities::Any
	data_sample::Any
	solver::Any
	p_true::Any
	ic::Any
	unident_count::Any
end

function fillPEP(pe::ParameterEstimationProblem; datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9())
	return ParameterEstimationProblem(
		pe.Name,
		complete(pe.model),
		pe.measured_quantities,
		sample_data(pe.model, pe.measured_quantities, time_interval, pe.p_true, pe.ic, datasize, solver = solver),
		solver,
		pe.p_true,
		pe.ic,
		pe.unident_count)

	return pe
end


function biohydrogenation()
	@parameters k5 k6 k7 k8 k9 k10
	@variables t x4(t) x5(t) x6(t) x7(t) y1(t) y2(t)
	D = Differential(t)
	states = [x4, x5, x6, x7]
	parameters = [k5, k6, k7, k8, k9, k10]

	@named model = ODESystem([
			D(x4) ~ -k5 * x4 / (k6 + x4),
			D(x5) ~ k5 * x4 / (k6 + x4) - k7 * x5 / (k8 + x5 + x6),
			D(x6) ~ k7 * x5 / (k8 + x5 + x6) - k9 * x6 * (k10 - x6) / k10,
			D(x7) ~ k9 * x6 * (k10 - x6) / k10,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x4,
		y2 ~ x5,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.143, 0.286, 0.429, 0.571, 0.714, 0.857]
	return ParameterEstimationProblem("BioHydrogenation",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 1)
end

function crauste()
	@parameters mu_N mu_EE mu_LE mu_LL mu_M mu_P mu_PE mu_PL delta_NE delta_EL delta_LM rho_E rho_P
	@variables t N(t) E(t) S(t) M(t) P(t) y1(t) y2(t) y3(t) y4(t)
	D = Differential(t)
	states = [N, E, S, M, P]
	parameters = [
		mu_N,
		mu_EE,
		mu_LE,
		mu_LL,
		mu_M,
		mu_P,
		mu_PE,
		mu_PL,
		delta_NE,
		delta_EL,
		delta_LM,
		rho_E,
		rho_P,
	]
	@named model = ODESystem(
		[
			D(N) ~ -N * mu_N - N * P * delta_NE,
			D(E) ~ N * P * delta_NE - E^2 * mu_EE -
				   E * delta_EL + E * P * rho_E,
			D(S) ~ S * delta_EL - S * delta_LM - S^2 * mu_LL -
				   E * S * mu_LE,
			D(M) ~ S * delta_LM - mu_M * M,
			D(P) ~ P^2 * rho_P - P * mu_P - E * P * mu_PE -
				   S * P * mu_PL,
		], t, states, parameters)
	measured_quantities = [y1 ~ N, y2 ~ E, y3 ~ S + M, y4 ~ P]

	ic = [0.167, 0.333, 0.5, 0.667, 0.833]
	p_true = [
		0.071,
		0.143,
		0.214,
		0.286,
		0.357,
		0.429,
		0.5,
		0.571,
		0.643,
		0.714,
		0.786,
		0.857,
		0.929,
	] # True Parameters

	return ParameterEstimationProblem("Crauste",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function daisy_ex3()
	@parameters p1 p3 p4 p6 p7
	@variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, u0]
	parameters = [p1, p3, p4, p6, p7]
	@named model = ODESystem([
			D(x1) ~ -1.0 * p1 * x1 + x2 + u0,
			D(x2) ~ p3 * x1 - p4 * x2 + x3,
			D(x3) ~ p6 * x1 - p7 * x3,
			D(u0) ~ 1.0,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ u0,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.167, 0.333, 0.5, 0.667, 0.833] # True Parameters


	return ParameterEstimationProblem("DAISY_ex3",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end



function daisy_ex3_v2()
	@parameters p1 p3 p4 p6 p7
	@variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, u0]
	parameters = [p1, p3, p4, p6, p7]
	@named model = ODESystem([
			D(x1) ~ -1.0 * p1 * x1 + x2 + u0,
			D(x2) ~ p3 * x1 - p4 * x2 + x3,
			D(x3) ~ p6 * x1 - p7 * x3,
			D(u0) ~ 1.0,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ u0,
	]
	ic = [1.0, 2.0, 1.0, 1.0]
	p_true = [0.2, 0.3, 0.5, 0.6, -0.2] # True Parameters



	return ParameterEstimationProblem("DAISY_ex3_v2",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end



function daisy_ex3_v3()
	@parameters p1 p3 p4 p6 p7 pd
	@variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, u0]
	parameters = [p1, p3, p4, p6, p7, pd]
	@named model = ODESystem([
			D(x1) ~ x2 + u0 - p1 * x1,
			D(x2) ~ p3 * x1 - p4 * x2 + x3,
			D(x3) ~ p6 * x1 - p7 * x3,
			D(u0) ~ pd,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ u0,
	]

	ic = [1.0, 2.0, 1.0, 1.0]
	p_true = [0.2, 0.3, 0.5, 0.6, -0.2, 1.0] # True Parameters

	return ParameterEstimationProblem("DAISY_ex3_v3",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end



function daisy_ex3_v4()
	@parameters p1 p3 p4 p6 p7 pd
	@variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, u0]
	parameters = [p1, p3, p4, p6, p7, pd]
	@named model = ODESystem([
			D(x1) ~ x2 + u0 - p1 * x1,
			D(x2) ~ p3 * x1 - p4 * x2 + x3,
			D(x3) ~ p6 * x1 - p7 * x3,
			D(u0) ~ pd,
		], t, states, parameters)
	measured_quantities = [y1 ~ x1 + x3, y2 ~ x2]


	ic = [1.0, 2.0, 1.0, 1.0]
	p_true = [0.2, 0.3, 0.5, 0.6, -0.2, 1.0] # True Parameters

	return ParameterEstimationProblem("DAISY_ex3_v4",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end






function daisy_mamil3(datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9())
	@parameters a12 a13 a21 a31 a01
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t)
	D = Differential(t)

	ic = [0.25, 0.5, 0.75]
	sampling_times = range(time_interval[1], time_interval[2], length = datasize)
	p_true = [0.167, 0.333, 0.5, 0.667, 0.833] # True Parameters

	states = [x1, x2, x3]
	parameters = [a12, a13, a21, a31, a01]
	@named model = ODESystem([D(x1) ~ -(a21 + a31 + a01) * x1 + a12 * x2 + a13 * x3,
			D(x2) ~ a21 * x1 - a12 * x2,
			D(x3) ~ a31 * x1 - a13 * x3],
		t, states, parameters)
	measured_quantities = [y1 ~ x1, y2 ~ x2]


	return ParameterEstimationProblem("DAISY_mamil3",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function daisy_mamil4(datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9())
	@parameters k01, k12, k13, k14, k21, k31, k41
	@variables t x1(t) x2(t) x3(t) x4(t) y1(t) y2(t) y3(t)
	D = Differential(t)

	ic = [0.2, 0.4, 0.6, 0.8]
	sampling_times = range(time_interval[1], time_interval[2], length = datasize)
	p_true = [0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875] # True Parameters

	states = [x1, x2, x3, x4]
	parameters = [k01, k12, k13, k14, k21, k31, k41]
	@named model = ODESystem([
			D(x1) ~ -k01 * x1 + k12 * x2 + k13 * x3 + k14 * x4 - k21 * x1 - k31 * x1 -
					k41 * x1,
			D(x2) ~ -k12 * x2 + k21 * x1,
			D(x3) ~ -k13 * x3 + k31 * x1,
			D(x4) ~ -k14 * x4 + k41 * x1],
		t, states, parameters)
	measured_quantities = [y1 ~ x1, y2 ~ x2, y3 ~ x3 + x4]


	return ParameterEstimationProblem("DAISY_mamil4",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function fitzhugh_nagumo()
	@parameters g a b
	@variables t V(t) R(t) y1(t) y2(t)
	D = Differential(t)
	states = [V, R]
	parameters = [g, a, b]

	ic = [0.333, 0.67]
	#sampling_times = range(time_interval[1], time_interval[2], length = datasize)
	p_true = [0.25, 0.5, 0.75] # True Parameters
	measured_quantities = [y1 ~ V]

	@named model = ODESystem([
			D(V) ~ g * (V - V^3 / 3 + R),
			D(R) ~ 1 / g * (V - a + b * R),
		], t, states, parameters)

	return ParameterEstimationProblem("fitzhugh-nagumo",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function hiv_local()
	@parameters b c d k1 k2 mu1 mu2 q1 q2 s
	@variables t x1(t) x2(t) x3(t) x4(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, x4]
	parameters = [b, c, d, k1, k2, mu1, mu2, q1, q2, s]

	@named model = ODESystem([
			D(x1) ~ -b * x1 * x4 - d * x1 + s,
			D(x2) ~ b * q1 * x1 * x4 - k1 * x2 - mu1 * x2,
			D(x3) ~ b * q2 * x1 * x4 + k1 * x2 - mu2 * x3,
			D(x4) ~ -c * x4 + k2 * x3,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x4,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.091, 0.182, 0.273, 0.364, 0.455, 0.545, 0.636, 0.727, 0.818, 0.909]
	time_interval = [-0.5, 0.5]
	datasize = 20

	return ParameterEstimationProblem("hiv_local",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 7)
end

function hiv()
	@parameters lm d beta a k u c q b h
	@variables t x(t) y(t) v(t) w(t) z(t) y1(t) y2(t) y3(t) y4(t)
	D = Differential(t)
	states = [x, y, v, w, z]
	parameters = [lm, d, beta, a, k, u, c, q, b, h]

	@named model = ODESystem([
			D(x) ~ lm - d * x - beta * x * v,
			D(y) ~ beta * x * v - a * y,
			D(v) ~ k * y - u * v,
			D(w) ~ c * x * y * w - c * q * y * w - b * w,
			D(z) ~ c * q * y * w - h * z,
		], t, states, parameters)
	measured_quantities = [y1 ~ w, y2 ~ z, y3 ~ x, y4 ~ y + v]

	ic = [0.167, 0.333, 0.5, 0.667, 0.833]
	p_true = [0.091, 0.181, 0.273, 0.364, 0.455, 0.545, 0.636, 0.727, 0.818, 0.909]


	return ParameterEstimationProblem("hiv",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function lotka_volterra()
	@parameters k1 k2 k3
	@variables t r(t) w(t) y1(t)
	D = Differential(t)
	ic = [0.333, 0.667]
	p_true = [0.25, 0.5, 0.75] # True Parameters
	measured_quantities = [y1 ~ r]
	states = [r, w]
	parameters = [k1, k2, k3]

	@named model = ODESystem([
			D(r) ~ k1 * r - k2 * r * w,
			D(w) ~ k2 * r * w - k3 * w], t,
		states, parameters)

	return ParameterEstimationProblem("Lotka_Volterra", model, measured_quantities,
		:nothing, :nothing, p_true, ic, 0)
end

function seir()
	@parameters a b nu
	@variables t S(t) E(t) In(t) N(t) y1(t) y2(t)
	D = Differential(t)
	states = [S, E, In, N]
	parameters = [a, b, nu]

	@named model = ODESystem([
			D(S) ~ -b * S * In / N,
			D(E) ~ b * S * In / N - nu * E,
			D(In) ~ nu * E - a * In,
			D(N) ~ 0,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ In,
		y2 ~ N,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.25, 0.5, 0.75]

	return ParameterEstimationProblem("SEIR",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function simple()
	@parameters a b
	@variables t x1(t) x2(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2]
	parameters = [a, b]

	@named model = ODESystem([
			D(x1) ~ -a * x2,
			D(x2) ~ b * x1,  #edited from 1/b
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2]

	ic = [0.333, 0.667]
	p_true = [0.4, 0.8]

	return ParameterEstimationProblem("simple",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function sirsforced()
	@parameters b0 b1 g M mu nu
	@variables t i(t) r(t) s(t) x1(t) x2(t) y1(t) y2(t)
	D = Differential(t)
	states = [i, r, s, x1, x2]
	parameters = [b0, b1, g, M, mu, nu]

	@named model = ODESystem([
			D(i) ~ b0 * (1.0 + b1 * x1) * i * s - (nu + mu) * i,
			D(r) ~ nu * i - (mu + g) * r,
			D(s) ~ mu - mu * s - b0 * (1.0 + b1 * x1) * i * s + g * r,
			D(x1) ~ -M * x2,
			D(x2) ~ M * x1,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ i,
		y2 ~ r,
	]

	ic = [0.167, 0.333, 0.5, 0.667, 0.833]
	p_true = [0.143, 0.286, 0.429, 0.571, 0.714, 0.857]

	return ParameterEstimationProblem("sirsforced",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 3)
end

function slowfast()  # TODO(orebas):in the old code it was CVODE_BDF.  should we go back to that?
	#solver = CVODE_BDF()
	@parameters k1 k2 eB
	@variables t xA(t) xB(t) xC(t) eA(t) eC(t) y1(t) y2(t) y3(t) y4(t) eA(t) eC(t)
	D = Differential(t)
	states = [xA, xB, xC, eA, eC]
	parameters = [k1, k2, eB]
	@named model = ODESystem([
			D(xA) ~ -k1 * xA,
			D(xB) ~ k1 * xA - k2 * xB,
			D(xC) ~ k2 * xB,
			D(eA) ~ 0.0,
			D(eC) ~ 0.0,
		], t, states, parameters)

	measured_quantities = [y1 ~ xC, y2 ~ eA * xA + eB * xB + eC * xC, y3 ~ eA, y4 ~ eC]
	ic = [0.166, 0.333, 0.5, 0.666, 0.833]
	p_true = [0.25, 0.5, 0.75] # True Parameters

	return ParameterEstimationProblem("slowfast",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end


function substr_test()
	@parameters a b beta
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t) y3(t)
	D = Differential(t)
	states = [x1, x2, x3]
	parameters = [a, b, beta]

	@named model = ODESystem([
			D(x1) ~ -a * x2,
			D(x2) ~ b * (x1),
			D(x3) ~ a * b * beta * b * a * x3,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2,
		y3 ~ x3,
	]

	ic = [2.0, 3.0, 4.0]
	p_true = [0.1, 0.2, 0.3]

	return ParameterEstimationProblem("substr_test",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end


function global_unident_test()
	@parameters a b c d
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3]
	parameters = [a, b, c, d]

	@named model = ODESystem([
			D(x1) ~ -a * x1,
			D(x2) ~ (b + c) * (x1),
			D(x3) ~ d * x1,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2,
	]

	ic = [2.0, 3.0, 4.0]
	p_true = [0.1, 0.2, 0.3, 0.4]

	return ParameterEstimationProblem("global_unident_test",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 4)

end


function sum_test()
	@parameters a b c d
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3]
	parameters = [a, b, c]

	@named model = ODESystem([
			D(x1) ~ -a * x1,
			D(x2) ~ b * (x2),
			D(x3) ~ c * (x1 + x2),
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x3,
	]

	ic = [2.0, 3.0, 4.0]
	p_true = [0.1, 0.2, 0.3]

	return ParameterEstimationProblem("sum_test",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 3)

end





function treatment(datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9())  #note the solver.  Vern9 apparently can't handle mass matrices
	@parameters a b d g nu
	@variables t In(t) N(t) S(t) Tr(t) y1(t) y2(t)
	D = Differential(t)
	states = [In, N, S, Tr]
	parameters = [a, b, d, g, nu]

	@named model = ODESystem([D(In) ~ b * S * In / N + d * b * S * Tr / N - (a + g) * In,
			D(N) ~ 0,
			D(S) ~ -b * S * In / N - d * b * S * Tr / N,
			D(Tr) ~ g * In - nu * Tr], t, states, parameters)
	measured_quantities = [
		y1 ~ Tr,
		y2 ~ N,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.167, 0.333, 0.5, 0.667, 0.833]

	return ParameterEstimationProblem("treatment",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 6)
end

function vanderpol()
	@parameters a b
	@variables t x1(t) x2(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2]
	parameters = [a, b]

	@named model = ODESystem([
			D(x1) ~ a * x2,
			D(x2) ~ -(x1) - b * (x1^2 - 1) * (x2),
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2,
	]

	ic = [0.333, 0.667]
	p_true = [0.4, 0.8]

	return ParameterEstimationProblem("vanderpol",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function analyze_parameter_estimation_problem(PEP::ParameterEstimationProblem; test_mode = false, showplot = true, run_ode_pe = true)

	#interpolators = Dict(
	#	"AAA" => ParameterEstimation.aaad,
	#"FHD3" => ParameterEstimation.fhdn(3),
	#"FHD6" => ParameterEstimation.fhdn(6),
	#"FHD8" => ParameterEstimation.fhdn(8),
	#"Fourier" => ParameterEstimation.FourierInterp,
	#)
	datasize = 21 #TODO(Orebas) magic number

	#stepsize = max(1, datasize ÷ 8)
	#for i in range(1, (datasize - 2), step = stepsize)
	#	interpolators["RatOld($i)"] = ParameterEstimation.SimpleRationalInterpOld(i)
	#end

	#@time res = ParameterEstimation.estimate(PEP.model, PEP.measured_quantities,
	#	PEP.data_sample,
	#	solver = PEP.solver, disable_output = false, interpolators = interpolators)
	#all_params = vcat(PEP.ic, PEP.p_true)
	#println("TYPERES: ", typeof(res))
	#println(res)

	#println(res)
	besterror = 1e30
	all_params = vcat(PEP.ic, PEP.p_true)

	if (run_ode_pe)
		println("Starting model: ", PEP.Name)
		@time PEP.Name res3 = ODEPEtestwrapper(PEP.model, PEP.measured_quantities,
			PEP.data_sample,
			PEP.solver)
		besterror = 1e30
		res3 = sort(res3, by = x -> x.err)
		display("How close are we?")
		println("Actual values:")
		display(all_params)

		for each in res3

			estimates = vcat(collect(values(each.states)), collect(values(each.parameters)))
			if (each.err < 100)  #TODO: magic number

				display(estimates)
				println("Error: ", each.err)
			end

			errorvec = abs.((estimates .- all_params) ./ (all_params))
			if (PEP.unident_count > 0)
				sort!(errorvec)
				for i in 1:PEP.unident_count
					pop!(errorvec)
				end
			end
			besterror = min(besterror, maximum(errorvec))
		end

		if (test_mode)
			#@test besterror < 1e-1
		end
		println("For model ", PEP.Name, ": The ODEPE  max abs rel. err: ", besterror)
	end
end

function varied_estimation_main()
	print("testing")
	#datasize = 21
	#solver = AutoVern9(Rodas5())
	solver = Vern9()
	#solver = Rodas4P()
	#time_interval = [-0.5, 0.5]
	#datasize = 21

	time_interval = [-0.5, 0.5]
	datasize = 21

	for PEP in [
		#crauste(),
		#sirsforced(),
		#slowfast(),



		simple(),
		substr_test(),
		vanderpol(),
		daisy_mamil3(),
		fitzhugh_nagumo(),
		slowfast(),
		daisy_ex3_v3(),
		daisy_ex3_v2(),
		daisy_ex3_v4(),
		sum_test(),
		daisy_mamil4(),
		lotka_volterra(),
		global_unident_test(),
		daisy_ex3(),
		hiv(),
		seir(),
		hiv_local(),
		biohydrogenation(),
		treatment(),
		crauste(),  #these seem to be the slowest
		sirsforced(), #these seem to be the slowest
	]
		analyze_parameter_estimation_problem(fillPEP(PEP, datasize = datasize, time_interval = time_interval), test_mode = false, showplot = true)
	end
end

varied_estimation_main()
# Write your tests here.

================
File: examples/main_tests.jl
================
using ODEParameterEstimation
using Test
using ModelingToolkit
using HomotopyContinuation
using DifferentialEquations
using OrderedCollections
#using ParameterEstimation



struct ParameterEstimationProblem
	Name::Any
	model::Any
	measured_quantities::Any
	data_sample::Any
	solver::Any
	p_true::Any
	ic::Any
	unident_count::Any
end

function fillPEP(pe::ParameterEstimationProblem; datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9())
	return ParameterEstimationProblem(
		pe.Name,
		complete(pe.model),
		pe.measured_quantities,
		sample_data(pe.model, pe.measured_quantities, time_interval, pe.p_true, pe.ic, datasize, solver = solver),
		solver,
		pe.p_true,
		pe.ic,
		pe.unident_count)

	return pe
end


function biohydrogenation()
	@parameters k5 k6 k7 k8 k9 k10
	@variables t x4(t) x5(t) x6(t) x7(t) y1(t) y2(t)
	D = Differential(t)
	states = [x4, x5, x6, x7]
	parameters = [k5, k6, k7, k8, k9, k10]

	@named model = ODESystem([
			D(x4) ~ -k5 * x4 / (k6 + x4),
			D(x5) ~ k5 * x4 / (k6 + x4) - k7 * x5 / (k8 + x5 + x6),
			D(x6) ~ k7 * x5 / (k8 + x5 + x6) - k9 * x6 * (k10 - x6) / k10,
			D(x7) ~ k9 * x6 * (k10 - x6) / k10,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x4,
		y2 ~ x5,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.143, 0.286, 0.429, 0.571, 0.714, 0.857]
	return ParameterEstimationProblem("BioHydrogenation",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 1)
end

function crauste()
	@parameters mu_N mu_EE mu_LE mu_LL mu_M mu_P mu_PE mu_PL delta_NE delta_EL delta_LM rho_E rho_P
	@variables t N(t) E(t) S(t) M(t) P(t) y1(t) y2(t) y3(t) y4(t)
	D = Differential(t)
	states = [N, E, S, M, P]
	parameters = [
		mu_N,
		mu_EE,
		mu_LE,
		mu_LL,
		mu_M,
		mu_P,
		mu_PE,
		mu_PL,
		delta_NE,
		delta_EL,
		delta_LM,
		rho_E,
		rho_P,
	]
	@named model = ODESystem(
		[
			D(N) ~ -N * mu_N - N * P * delta_NE,
			D(E) ~ N * P * delta_NE - E^2 * mu_EE -
				   E * delta_EL + E * P * rho_E,
			D(S) ~ S * delta_EL - S * delta_LM - S^2 * mu_LL -
				   E * S * mu_LE,
			D(M) ~ S * delta_LM - mu_M * M,
			D(P) ~ P^2 * rho_P - P * mu_P - E * P * mu_PE -
				   S * P * mu_PL,
		], t, states, parameters)
	measured_quantities = [y1 ~ N, y2 ~ E, y3 ~ S + M, y4 ~ P]

	ic = [0.167, 0.333, 0.5, 0.667, 0.833]
	p_true = [
		0.071,
		0.143,
		0.214,
		0.286,
		0.357,
		0.429,
		0.5,
		0.571,
		0.643,
		0.714,
		0.786,
		0.857,
		0.929,
	] # True Parameters

	return ParameterEstimationProblem("Crauste",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function daisy_ex3()
	@parameters p1 p3 p4 p6 p7
	@variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, u0]
	parameters = [p1, p3, p4, p6, p7]
	@named model = ODESystem([
			D(x1) ~ -1.0 * p1 * x1 + x2 + u0,
			D(x2) ~ p3 * x1 - p4 * x2 + x3,
			D(x3) ~ p6 * x1 - p7 * x3,
			D(u0) ~ 1.0,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ u0,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.167, 0.333, 0.5, 0.667, 0.833] # True Parameters


	return ParameterEstimationProblem("DAISY_ex3",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end



function daisy_ex3_v2()
	@parameters p1 p3 p4 p6 p7
	@variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, u0]
	parameters = [p1, p3, p4, p6, p7]
	@named model = ODESystem([
			D(x1) ~ -1.0 * p1 * x1 + x2 + u0,
			D(x2) ~ p3 * x1 - p4 * x2 + x3,
			D(x3) ~ p6 * x1 - p7 * x3,
			D(u0) ~ 1.0,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ u0,
	]
	ic = [1.0, 2.0, 1.0, 1.0]
	p_true = [0.2, 0.3, 0.5, 0.6, -0.2] # True Parameters



	return ParameterEstimationProblem("DAISY_ex3_v2",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end



function daisy_ex3_v3()
	@parameters p1 p3 p4 p6 p7 pd
	@variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, u0]
	parameters = [p1, p3, p4, p6, p7, pd]
	@named model = ODESystem([
			D(x1) ~ x2 + u0 - p1 * x1,
			D(x2) ~ p3 * x1 - p4 * x2 + x3,
			D(x3) ~ p6 * x1 - p7 * x3,
			D(u0) ~ pd,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ u0,
	]

	ic = [1.0, 2.0, 1.0, 1.0]
	p_true = [0.2, 0.3, 0.5, 0.6, -0.2, 1.0] # True Parameters

	return ParameterEstimationProblem("DAISY_ex3_v3",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end



function daisy_ex3_v4()
	@parameters p1 p3 p4 p6 p7 pd
	@variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, u0]
	parameters = [p1, p3, p4, p6, p7, pd]
	@named model = ODESystem([
			D(x1) ~ x2 + u0 - p1 * x1,
			D(x2) ~ p3 * x1 - p4 * x2 + x3,
			D(x3) ~ p6 * x1 - p7 * x3,
			D(u0) ~ pd,
		], t, states, parameters)
	measured_quantities = [y1 ~ x1 + x3, y2 ~ x2]


	ic = [1.0, 2.0, 1.0, 1.0]
	p_true = [0.2, 0.3, 0.5, 0.6, -0.2, 1.0] # True Parameters

	return ParameterEstimationProblem("DAISY_ex3_v4",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end






function daisy_mamil3(datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9())
	@parameters a12 a13 a21 a31 a01
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t)
	D = Differential(t)

	ic = [0.25, 0.5, 0.75]
	sampling_times = range(time_interval[1], time_interval[2], length = datasize)
	p_true = [0.167, 0.333, 0.5, 0.667, 0.833] # True Parameters

	states = [x1, x2, x3]
	parameters = [a12, a13, a21, a31, a01]
	@named model = ODESystem([D(x1) ~ -(a21 + a31 + a01) * x1 + a12 * x2 + a13 * x3,
			D(x2) ~ a21 * x1 - a12 * x2,
			D(x3) ~ a31 * x1 - a13 * x3],
		t, states, parameters)
	measured_quantities = [y1 ~ x1, y2 ~ x2]


	return ParameterEstimationProblem("DAISY_mamil3",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function daisy_mamil4(datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9())
	@parameters k01, k12, k13, k14, k21, k31, k41
	@variables t x1(t) x2(t) x3(t) x4(t) y1(t) y2(t) y3(t)
	D = Differential(t)

	ic = [0.2, 0.4, 0.6, 0.8]
	sampling_times = range(time_interval[1], time_interval[2], length = datasize)
	p_true = [0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875] # True Parameters

	states = [x1, x2, x3, x4]
	parameters = [k01, k12, k13, k14, k21, k31, k41]
	@named model = ODESystem([
			D(x1) ~ -k01 * x1 + k12 * x2 + k13 * x3 + k14 * x4 - k21 * x1 - k31 * x1 -
					k41 * x1,
			D(x2) ~ -k12 * x2 + k21 * x1,
			D(x3) ~ -k13 * x3 + k31 * x1,
			D(x4) ~ -k14 * x4 + k41 * x1],
		t, states, parameters)
	measured_quantities = [y1 ~ x1, y2 ~ x2, y3 ~ x3 + x4]


	return ParameterEstimationProblem("DAISY_mamil4",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function fitzhugh_nagumo()
	@parameters g a b
	@variables t V(t) R(t) y1(t) y2(t)
	D = Differential(t)
	states = [V, R]
	parameters = [g, a, b]

	ic = [0.333, 0.67]
	#sampling_times = range(time_interval[1], time_interval[2], length = datasize)
	p_true = [0.25, 0.5, 0.75] # True Parameters
	measured_quantities = [y1 ~ V]

	@named model = ODESystem([
			D(V) ~ g * (V - V^3 / 3 + R),
			D(R) ~ 1 / g * (V - a + b * R),
		], t, states, parameters)

	return ParameterEstimationProblem("fitzhugh-nagumo",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function hiv_local()
	@parameters b c d k1 k2 mu1 mu2 q1 q2 s
	@variables t x1(t) x2(t) x3(t) x4(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, x4]
	parameters = [b, c, d, k1, k2, mu1, mu2, q1, q2, s]

	@named model = ODESystem([
			D(x1) ~ -b * x1 * x4 - d * x1 + s,
			D(x2) ~ b * q1 * x1 * x4 - k1 * x2 - mu1 * x2,
			D(x3) ~ b * q2 * x1 * x4 + k1 * x2 - mu2 * x3,
			D(x4) ~ -c * x4 + k2 * x3,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x4,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.091, 0.182, 0.273, 0.364, 0.455, 0.545, 0.636, 0.727, 0.818, 0.909]
	time_interval = [-0.5, 0.5]
	datasize = 20

	return ParameterEstimationProblem("hiv_local",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 7)
end

function hiv()
	@parameters lm d beta a k u c q b h
	@variables t x(t) y(t) v(t) w(t) z(t) y1(t) y2(t) y3(t) y4(t)
	D = Differential(t)
	states = [x, y, v, w, z]
	parameters = [lm, d, beta, a, k, u, c, q, b, h]

	@named model = ODESystem([
			D(x) ~ lm - d * x - beta * x * v,
			D(y) ~ beta * x * v - a * y,
			D(v) ~ k * y - u * v,
			D(w) ~ c * x * y * w - c * q * y * w - b * w,
			D(z) ~ c * q * y * w - h * z,
		], t, states, parameters)
	measured_quantities = [y1 ~ w, y2 ~ z, y3 ~ x, y4 ~ y + v]

	ic = [0.167, 0.333, 0.5, 0.667, 0.833]
	p_true = [0.091, 0.181, 0.273, 0.364, 0.455, 0.545, 0.636, 0.727, 0.818, 0.909]


	return ParameterEstimationProblem("hiv",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function lotka_volterra()
	@parameters k1 k2 k3
	@variables t r(t) w(t) y1(t)
	D = Differential(t)
	ic = [0.333, 0.667]
	p_true = [0.25, 0.5, 0.75] # True Parameters
	measured_quantities = [y1 ~ r]
	states = [r, w]
	parameters = [k1, k2, k3]

	@named model = ODESystem([
			D(r) ~ k1 * r - k2 * r * w,
			D(w) ~ k2 * r * w - k3 * w], t,
		states, parameters)

	return ParameterEstimationProblem("Lotka_Volterra", model, measured_quantities,
		:nothing, :nothing, p_true, ic, 0)
end

function seir()
	@parameters a b nu
	@variables t S(t) E(t) In(t) N(t) y1(t) y2(t)
	D = Differential(t)
	states = [S, E, In, N]
	parameters = [a, b, nu]

	@named model = ODESystem([
			D(S) ~ -b * S * In / N,
			D(E) ~ b * S * In / N - nu * E,
			D(In) ~ nu * E - a * In,
			D(N) ~ 0,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ In,
		y2 ~ N,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.25, 0.5, 0.75]

	return ParameterEstimationProblem("SEIR",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function simple()
	@parameters a b
	@variables t x1(t) x2(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2]
	parameters = [a, b]

	@named model = ODESystem([
			D(x1) ~ -a * x2,
			D(x2) ~ b * x1,  #edited from 1/b
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2]

	ic = [0.333, 0.667]
	p_true = [0.4, 0.8]

	return ParameterEstimationProblem("simple",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function sirsforced()
	@parameters b0 b1 g M mu nu
	@variables t i(t) r(t) s(t) x1(t) x2(t) y1(t) y2(t)
	D = Differential(t)
	states = [i, r, s, x1, x2]
	parameters = [b0, b1, g, M, mu, nu]

	@named model = ODESystem([
			D(i) ~ b0 * (1.0 + b1 * x1) * i * s - (nu + mu) * i,
			D(r) ~ nu * i - (mu + g) * r,
			D(s) ~ mu - mu * s - b0 * (1.0 + b1 * x1) * i * s + g * r,
			D(x1) ~ -M * x2,
			D(x2) ~ M * x1,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ i,
		y2 ~ r,
	]

	ic = [0.167, 0.333, 0.5, 0.667, 0.833]
	p_true = [0.143, 0.286, 0.429, 0.571, 0.714, 0.857]

	return ParameterEstimationProblem("sirsforced",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 3)
end

function slowfast()  # TODO(orebas):in the old code it was CVODE_BDF.  should we go back to that?
	#solver = CVODE_BDF()
	@parameters k1 k2 eB
	@variables t xA(t) xB(t) xC(t) eA(t) eC(t) y1(t) y2(t) y3(t) y4(t) eA(t) eC(t)
	D = Differential(t)
	states = [xA, xB, xC, eA, eC]
	parameters = [k1, k2, eB]
	@named model = ODESystem([
			D(xA) ~ -k1 * xA,
			D(xB) ~ k1 * xA - k2 * xB,
			D(xC) ~ k2 * xB,
			D(eA) ~ 0.0,
			D(eC) ~ 0.0,
		], t, states, parameters)

	measured_quantities = [y1 ~ xC, y2 ~ eA * xA + eB * xB + eC * xC, y3 ~ eA, y4 ~ eC]
	ic = [0.166, 0.333, 0.5, 0.666, 0.833]
	p_true = [0.25, 0.5, 0.75] # True Parameters

	return ParameterEstimationProblem("slowfast",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end


function substr_test()
	@parameters a b beta
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t) y3(t)
	D = Differential(t)
	states = [x1, x2, x3]
	parameters = [a, b, beta]

	@named model = ODESystem([
			D(x1) ~ -a * x2,
			D(x2) ~ b * (x1),
			D(x3) ~ a * b * beta * b * a * x3,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2,
		y3 ~ x3,
	]

	ic = [2.0, 3.0, 4.0]
	p_true = [0.1, 0.2, 0.3]

	return ParameterEstimationProblem("substr_test",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end


function global_unident_test()
	@parameters a b c d
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3]
	parameters = [a, b, c, d]

	@named model = ODESystem([
			D(x1) ~ -a * x1,
			D(x2) ~ (b + c) * (x1),
			D(x3) ~ d * x1,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2,
	]

	ic = [2.0, 3.0, 4.0]
	p_true = [0.1, 0.2, 0.3, 0.4]

	return ParameterEstimationProblem("global_unident_test",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 4)

end


function sum_test()
	@parameters a b c d
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3]
	parameters = [a, b, c]

	@named model = ODESystem([
			D(x1) ~ -a * x1,
			D(x2) ~ b * (x2),
			D(x3) ~ c * (x1 + x2),
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x3,
	]

	ic = [2.0, 3.0, 4.0]
	p_true = [0.1, 0.2, 0.3]

	return ParameterEstimationProblem("sum_test",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 3)

end





function treatment(datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9())  #note the solver.  Vern9 apparently can't handle mass matrices
	@parameters a b d g nu
	@variables t In(t) N(t) S(t) Tr(t) y1(t) y2(t)
	D = Differential(t)
	states = [In, N, S, Tr]
	parameters = [a, b, d, g, nu]

	@named model = ODESystem([D(In) ~ b * S * In / N + d * b * S * Tr / N - (a + g) * In,
			D(N) ~ 0,
			D(S) ~ -b * S * In / N - d * b * S * Tr / N,
			D(Tr) ~ g * In - nu * Tr], t, states, parameters)
	measured_quantities = [
		y1 ~ Tr,
		y2 ~ N,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.167, 0.333, 0.5, 0.667, 0.833]

	return ParameterEstimationProblem("treatment",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 6)
end

function vanderpol()
	@parameters a b
	@variables t x1(t) x2(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2]
	parameters = [a, b]

	@named model = ODESystem([
			D(x1) ~ a * x2,
			D(x2) ~ -(x1) - b * (x1^2 - 1) * (x2),
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2,
	]

	ic = [0.333, 0.667]
	p_true = [0.4, 0.8]

	return ParameterEstimationProblem("vanderpol",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function analyze_parameter_estimation_problem(PEP::ParameterEstimationProblem; test_mode = false, showplot = true, run_ode_pe = true)

	#interpolators = Dict(
	#	"AAA" => ParameterEstimation.aaad,
	#"FHD3" => ParameterEstimation.fhdn(3),
	#"FHD6" => ParameterEstimation.fhdn(6),
	#"FHD8" => ParameterEstimation.fhdn(8),
	#"Fourier" => ParameterEstimation.FourierInterp,
	#)
	datasize = 21 #TODO(Orebas) magic number

	#stepsize = max(1, datasize ÷ 8)
	#for i in range(1, (datasize - 2), step = stepsize)
	#	interpolators["RatOld($i)"] = ParameterEstimation.SimpleRationalInterpOld(i)
	#end

	#@time res = ParameterEstimation.estimate(PEP.model, PEP.measured_quantities,
	#	PEP.data_sample,
	#	solver = PEP.solver, disable_output = false, interpolators = interpolators)
	#all_params = vcat(PEP.ic, PEP.p_true)
	#println("TYPERES: ", typeof(res))
	#println(res)

	#println(res)
	besterror = 1e30
	all_params = vcat(PEP.ic, PEP.p_true)

	if (run_ode_pe)
		println("Starting model: ", PEP.Name)
		@time PEP.Name res3 = ODEPEtestwrapper(PEP.model, PEP.measured_quantities,
			PEP.data_sample,
			PEP.solver)
		besterror = 1e30
		res3 = sort(res3, by = x -> x.err)
		display("How close are we?")
		println("Actual values:")
		display(all_params)

		for each in res3

			estimates = vcat(collect(values(each.states)), collect(values(each.parameters)))
			if (each.err < 100)  #TODO: magic number

				display(estimates)
				println("Error: ", each.err)
			end

			errorvec = abs.((estimates .- all_params) ./ (all_params))
			if (PEP.unident_count > 0)
				sort!(errorvec)
				for i in 1:PEP.unident_count
					pop!(errorvec)
				end
			end
			besterror = min(besterror, maximum(errorvec))
		end

		if (test_mode)
			#@test besterror < 1e-1
		end
		println("For model ", PEP.Name, ": The ODEPE  max abs rel. err: ", besterror)
	end
end

function varied_estimation_main()
	print("testing")
	#datasize = 21
	#solver = AutoVern9(Rodas5())
	solver = Vern9()
	#solver = Rodas4P()
	#time_interval = [-0.5, 0.5]
	#datasize = 21

	time_interval = [-0.5, 0.5]
	datasize = 21

	for PEP in [
		slowfast(),


		#=
				simple(),
				substr_test(),
				vanderpol(),
				daisy_mamil3(),
				fitzhugh_nagumo(),
				slowfast(),
				daisy_ex3_v3(),
				daisy_ex3_v2(),
				daisy_ex3_v4(),
				sum_test(),
				daisy_mamil4(),
				lotka_volterra(),
				global_unident_test(),
				daisy_ex3(),
				hiv(),
				seir(),
				hiv_local(),
				biohydrogenation(),
				treatment(),
				crauste(),  #these seem to be the slowest
				sirsforced(), #these seem to be the slowest
		=#
	]
		analyze_parameter_estimation_problem(fillPEP(PEP, datasize = datasize, time_interval = time_interval), test_mode = false, showplot = true)
	end
end

varied_estimation_main()
# Write your tests here.

================
File: examples/simple.jl
================
using ModelingToolkit, DifferentialEquations
using ODEParameterEstimation

#using ParameterEstimation





function simple()
	@parameters a b
	@variables t x1(t) x2(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2]
	parameters = [a, b]

	@named model = ODESystem([
			D(x1) ~ -a * x2,
			D(x2) ~ b * x1,  #edited from 1/b
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2]

	ic = [0.333, 0.667]
	p_true = [0.4, 0.8]

	model = complete(model)
	data_sample = sample_data(model, measured_quantities, [-1.0, 1.0], p_true, ic, 19, solver = Vern9())

	ret = ODEPEtestwrapper(model, measured_quantities, data_sample, Vern9())

	display(ret)
	return ret
end

simple()

================
File: examples/trivial.jl
================
using ModelingToolkit, DifferentialEquations
using ODEParameterEstimation

#using ParameterEstimation





function simple()
	@parameters a b
	@variables t x1(t) y1(t)
	D = Differential(t)
	states = [x1]
	parameters = [a]

	@named model = ODESystem([
			D(x1) ~ a * x1,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1]

	ic = [0.333]
	p_true = [0.4]

	model = complete(model)
	data_sample = sample_data(model, measured_quantities, [-1.0, 1.0], p_true, ic, 19, solver = Vern9())

	ret = ODEPEtestwrapper(model, measured_quantities, data_sample, Vern9())

	display(ret)
	return ret
end

simple()

================
File: src/ODEParameterEstimation.jl
================
module ODEParameterEstimation

using ModelingToolkit: t_nounits as t, D_nounits as D
using ModelingToolkit
using OrdinaryDiffEq
using LinearAlgebra
using OrderedCollections
using BaryRational
using HomotopyContinuation
using TaylorDiff
using PrecompileTools
using ForwardDiff
using Random



"""
	ParameterEstimationResult

Struct to store the results of parameter estimation.

# Fields
- `parameters::AbstractDict`: Estimated parameters
- `states::AbstractDict`: Estimated states
- `at_time::Float64`: Time at which estimation is done
- `err::Union{Nothing, Float64}`: Error of estimation
- `return_code::Any`: Return code of the estimation process
- `datasize::Int64`: Size of the data used
- `report_time::Any`: Time at which the result is reported
"""
mutable struct ParameterEstimationResult
	parameters::AbstractDict
	states::AbstractDict
	at_time::Float64
	err::Union{Nothing, Float64}
	return_code::Any
	datasize::Int64
	report_time::Any
end

"""
	DerivativeData

Struct to store derivative data of state variable equations and measured quantity equations.
No substitutions are made.
The "cleared" versions are produced from versions of the state equations and measured quantity equations
which have had their denominators cleared, i.e. they should be polynomial and never rational.

# Fields
- `states_lhs_cleared::Any`: Left-hand side of cleared state equations
- `states_rhs_cleared::Any`: Right-hand side of cleared state equations
- `obs_lhs_cleared::Any`: Left-hand side of cleared observation equations
- `obs_rhs_cleared::Any`: Right-hand side of cleared observation equations
- `states_lhs::Any`: Left-hand side of state equations
- `states_rhs::Any`: Right-hand side of state equations
- `obs_lhs::Any`: Left-hand side of observation equations
- `obs_rhs::Any`: Right-hand side of observation equations
"""
mutable struct DerivativeData
	states_lhs_cleared::Any
	states_rhs_cleared::Any
	obs_lhs_cleared::Any
	obs_rhs_cleared::Any
	states_lhs::Any
	states_rhs::Any
	obs_lhs::Any
	obs_rhs::Any
end

include("utils.jl")
include("SharedUtils.jl")
include("bary_derivs.jl")
include("sample_data.jl")
include("equation_solvers.jl")
#include("single-point.jl")
include("test_utils.jl")

"""
	handle_simple_substitutions(eqns, varlist)

Look for equations like a-5.5 and replace a with 5.5.

# Arguments
- `eqns`: Equations to process
- `varlist`: List of variables

# Returns
- Tuple containing filtered equations, reduced variable list, trivial variables, and trivial dictionary
"""
function handle_simple_substitutions(eqns, varlist)
	trivial_dict = Dict()
	filtered_eqns = typeof(eqns)()
	trivial_vars = []
	for i in eqns

		g = Symbolics.get_variables(i)
		if (length(g) == 1 && Symbolics.degree(i) == 1)
			#display(i)
			thisvar = g[1]
			td = (polynomial_coeffs(i, (thisvar,)))[1]
			if (1 in Set(keys(td)))
				thisvarvalue = (-td[1] / td[thisvar])
				trivial_dict[thisvar] = thisvarvalue
				push!(trivial_vars, thisvar)
			else
				thisvarvalue = 0
				trivial_dict[thisvar] = thisvarvalue
				push!(trivial_vars, thisvar)
			end
		else
			push!(filtered_eqns, i)
		end
	end
	reduced_varlist = filter(x -> !(x in Set(trivial_vars)), varlist)
	filtered_eqns = Symbolics.substitute.(filtered_eqns, Ref(trivial_dict))
	return filtered_eqns, reduced_varlist, trivial_vars, trivial_dict
end




"""
	populate_derivatives(model::ODESystem, measured_quantities_in, max_deriv_level, unident_dict)

Populate a DerivativeData object by taking derivatives of state variable and measured quantity equations.
diff2term is applied everywhere, so we will be left with variables like x_tttt etc.

# Arguments
- `model::ODESystem`: The ODE system
- `measured_quantities_in`: Input measured quantities
- `max_deriv_level`: Maximum derivative level
- `unident_dict`: Dictionary of unidentifiable variables

# Returns
- DerivativeData object
"""
function populate_derivatives(model::ODESystem, measured_quantities_in, max_deriv_level, unident_dict)
	(t, model_eq, model_states, model_ps) = unpack_ODE(model)
	measured_quantities = deepcopy(measured_quantities_in)


	states_count = length(model_states)
	ps_count = length(model_ps)
	D = Differential(t)

	DD = DerivativeData([], [], [], [], [], [], [], [])

	#First, we fully substitute values we have chosen for an unidentifiable variables.
	unident_subst!(model_eq, measured_quantities, unident_dict)

	model_eq_cleared = clear_denoms.(model_eq)
	measured_quantities_cleared = clear_denoms.(measured_quantities)


	DD.states_lhs = [[eq.lhs for eq in model_eq], expand_derivatives.(D.([eq.lhs for eq in model_eq]))]
	DD.states_rhs = [[eq.rhs for eq in model_eq], expand_derivatives.(D.([eq.rhs for eq in model_eq]))]
	DD.obs_lhs = [[eq.lhs for eq in measured_quantities], expand_derivatives.(D.([eq.lhs for eq in measured_quantities]))]
	DD.obs_rhs = [[eq.rhs for eq in measured_quantities], expand_derivatives.(D.([eq.rhs for eq in measured_quantities]))]

	DD.states_lhs_cleared = [[eq.lhs for eq in model_eq_cleared], expand_derivatives.(D.([eq.lhs for eq in model_eq_cleared]))]
	DD.states_rhs_cleared = [[eq.rhs for eq in model_eq_cleared], expand_derivatives.(D.([eq.rhs for eq in model_eq_cleared]))]
	DD.obs_lhs_cleared = [[eq.lhs for eq in measured_quantities_cleared], expand_derivatives.(D.([eq.lhs for eq in measured_quantities_cleared]))]
	DD.obs_rhs_cleared = [[eq.rhs for eq in measured_quantities_cleared], expand_derivatives.(D.([eq.rhs for eq in measured_quantities_cleared]))]


	for i in 1:(max_deriv_level-2)
		push!(DD.states_lhs, expand_derivatives.(D.(DD.states_lhs[end])))  #this constructs the derivatives of the state equations
		push!(DD.states_rhs, expand_derivatives.(D.(DD.states_rhs[end])))
		push!(DD.states_lhs_cleared, expand_derivatives.(D.(DD.states_lhs_cleared[end])))  #this constructs the derivatives of the state equations
		push!(DD.states_rhs_cleared, expand_derivatives.(D.(DD.states_rhs_cleared[end])))
	end
	for i in eachindex(DD.states_rhs), j in eachindex(DD.states_rhs[i])
		DD.states_rhs[i][j] = ModelingToolkit.diff2term(expand_derivatives(DD.states_rhs[i][j]))
		DD.states_lhs[i][j] = ModelingToolkit.diff2term(expand_derivatives(DD.states_lhs[i][j])) #applies differential operator everywhere.  
		DD.states_rhs_cleared[i][j] = ModelingToolkit.diff2term(expand_derivatives(DD.states_rhs_cleared[i][j]))
		DD.states_lhs_cleared[i][j] = ModelingToolkit.diff2term(expand_derivatives(DD.states_lhs_cleared[i][j])) #applies differential operator everywhere.  
	end

	for i in 1:(max_deriv_level-1)
		push!(DD.obs_lhs, expand_derivatives.(D.(DD.obs_lhs[end])))
		push!(DD.obs_rhs, expand_derivatives.(D.(DD.obs_rhs[end])))
		push!(DD.obs_lhs_cleared, expand_derivatives.(D.(DD.obs_lhs_cleared[end])))
		push!(DD.obs_rhs_cleared, expand_derivatives.(D.(DD.obs_rhs_cleared[end])))

	end

	for i in eachindex(DD.obs_rhs), j in eachindex(DD.obs_rhs[i])
		DD.obs_rhs[i][j] = ModelingToolkit.diff2term(expand_derivatives(DD.obs_rhs[i][j]))
		DD.obs_lhs[i][j] = ModelingToolkit.diff2term(expand_derivatives(DD.obs_lhs[i][j]))
		DD.obs_rhs_cleared[i][j] = ModelingToolkit.diff2term(expand_derivatives(DD.obs_rhs_cleared[i][j]))
		DD.obs_lhs_cleared[i][j] = ModelingToolkit.diff2term(expand_derivatives(DD.obs_lhs_cleared[i][j]))

	end
	return DD
end



"""
	multipoint_numerical_jacobian(model, measured_quantities_in, max_deriv_level::Int, max_num_points, unident_dict,
								  varlist, param_dict, ic_dict_vector, values_dict, DD = :nothing)

Compute the numerical Jacobian at multiple points.
the multiple points have different values for states, but the same parameters.


# Arguments
- `model`: The ODE model
- `measured_quantities_in`: Input measured quantities
- `max_deriv_level::Int`: Maximum derivative level
- `max_num_points`: Maximum number of points
- `unident_dict`: Dictionary of unidentifiable variables
- `varlist`: List of variables
- `param_dict`: Dictionary of parameters
- `ic_dict_vector`: Vector of initial condition dictionaries
- `values_dict`: Dictionary of values; we just use this to copy its shape
- `DD`: DerivativeData object (optional)

# Returns
- Tuple containing the Jacobian matrix and DerivativeData object
"""


function multipoint_numerical_jacobian(model, measured_quantities_in, max_deriv_level::Int, max_num_points, unident_dict,
	varlist, param_dict, ic_dict_vector, values_dict, DD = :nothing)
	(t, model_eq, model_states, model_ps) = unpack_ODE(model)
	measured_quantities = deepcopy(measured_quantities_in)

	states_count = length(model_states)
	ps_count = length(model_ps)
	D = Differential(t)
	subst_dict = Dict()

	num_real_params = length(keys(param_dict))
	num_real_states = length(keys(ic_dict_vector[1]))


	if (DD == :nothing)
		DD = populate_derivatives(model, measured_quantities, max_deriv_level, unident_dict)
	end

	function f(param_and_ic_values_vec)

		obs_deriv_vals = []
		for k in eachindex(ic_dict_vector)
			evaluated_subst_dict = OrderedDict{Any, Any}(deepcopy(values_dict))
			thekeys = collect(keys(evaluated_subst_dict))
			for i in 1:num_real_params
				evaluated_subst_dict[thekeys[i]] = param_and_ic_values_vec[i]  #this sets just the params
			end
			for i in 1:num_real_states  #this is wrong replace this
				evaluated_subst_dict[thekeys[i+num_real_params]] =  #check this?
					param_and_ic_values_vec[(k-1)*num_real_states+num_real_params+i]
			end

			for i in eachindex(DD.states_rhs)
				for j in eachindex(DD.states_rhs[i])
					evaluated_subst_dict[DD.states_lhs[i][j]] = substitute(DD.states_rhs[i][j], evaluated_subst_dict)
				end
			end
			for i in eachindex(DD.obs_rhs), j in eachindex(DD.obs_rhs[i])
				push!(obs_deriv_vals, (substitute(DD.obs_rhs[i][j], evaluated_subst_dict)))
			end
		end
		return obs_deriv_vals
	end

	full_values = collect(values(param_dict))
	for k in eachindex(ic_dict_vector)
		append!(full_values, collect(values(ic_dict_vector[k])))
	end
	matrix = ForwardDiff.jacobian(f, full_values)
	return Matrix{Float64}(matrix), DD

end


"""
	multipoint_deriv_level_view(evaluated_jac, deriv_level, num_obs, max_num_points, deriv_count, num_points_used)

Create a view of the Jacobian matrix for specific derivative levels and points.

# Arguments
- `evaluated_jac`: Evaluated Jacobian matrix
- `deriv_level`: Dictionary of derivative levels for each observable
- `num_obs`: Number of observables
- `max_num_points`: Maximum number of points
- `deriv_count`: Total number of derivatives
- `num_points_used`: Number of points actually used

# Returns
- View of the Jacobian matrix
"""
function multipoint_deriv_level_view(evaluated_jac, deriv_level, num_obs, max_num_points, deriv_count, num_points_used)
	function linear_index(which_obs, this_deriv_level, this_point)
		return this_deriv_level * num_obs + which_obs + (this_point - 1) * num_obs * (deriv_count + 1)
	end
	view_array = []
	for k in 1:num_points_used
		for (which_observable, max_deriv_level_this) in deriv_level
			for j in 0:max_deriv_level_this
				push!(view_array, linear_index(which_observable, j, k))
			end
		end
	end
	return view(evaluated_jac, view_array, :)

end



"""
	multipoint_local_identifiability_analysis(model::ODESystem, measured_quantities, max_num_points, rtol = 1e-12, atol = 1e-12)

Perform local identifiability analysis at multiple points.

# Arguments
- `model::ODESystem`: The ODE system
- `measured_quantities`: Measured quantities
- `max_num_points`: Maximum number of points to use
- `rtol`: Relative tolerance (default: 1e-12)
- `atol`: Absolute tolerance (default: 1e-12)

# Returns
- Tuple containing derivative levels, unidentifiable dictionary, variable list, and DerivativeData object
"""
function multipoint_local_identifiability_analysis(model::ODESystem, measured_quantities, max_num_points, rtol = 1e-12, atol = 1e-12)

	(t, model_eq, model_states, model_ps) = unpack_ODE(model)
	varlist = Vector{Num}(vcat(model_ps, model_states))

	states_count = length(model_states)
	ps_count = length(model_ps)
	D = Differential(t)

	#first, we construct a single (consistent) set of parameters, and n different sets of initial conditions
	parameter_values = Dict([p => rand(Float64) for p in ModelingToolkit.parameters(model)])
	points_ics = []
	test_points = []
	ordered_test_points = []

	for i in 1:max_num_points
		initial_conditions = Dict([p => rand(Float64) for p in ModelingToolkit.unknowns(model)])
		test_point = merge(parameter_values, initial_conditions)
		ordered_test_point = OrderedDict{SymbolicUtils.BasicSymbolic{Real}, Float64}()
		for i in model_ps
			ordered_test_point[i] = parameter_values[i]
		end
		for i in model_states
			ordered_test_point[i] = initial_conditions[i]
		end
		push!(points_ics, deepcopy(initial_conditions))
		push!(test_points, deepcopy(test_point))
		push!(ordered_test_points, deepcopy(ordered_test_point))
	end

	n = Int64(ceil((states_count + ps_count) / length(measured_quantities)) + 2)  #check this is sufficient, for the number of derivatives to take
	#see comment from non-multipoint version
	n = max(n, 3)
	deriv_level = Dict([p => n for p in 1:length(measured_quantities)])
	unident_dict = Dict()


	jac = nothing
	evaluated_jac = nothing
	DD = nothing

	all_identified = false
	while (!all_identified)
		(evaluated_jac, DD) = (multipoint_numerical_jacobian(model, measured_quantities, n, max_num_points, unident_dict, varlist,
			parameter_values, points_ics, ordered_test_points[1]))
		ns = nullspace(evaluated_jac)

		if (!isempty(ns))
			candidate_plugins_for_unidentified = OrderedDict()
			for i in eachindex(varlist)
				if (!isapprox(norm(ns[i, :]), 0.0, atol = atol))
					candidate_plugins_for_unidentified[varlist[i]] = test_points[1][varlist[i]]
				end
			end

			println("After making the following substitutions:", unident_dict, " the following are globally unidentifiable:",
				keys(candidate_plugins_for_unidentified))
			if (!isempty(candidate_plugins_for_unidentified))
				p = first(candidate_plugins_for_unidentified)
				deleteat!(varlist, findall(x -> isequal(x, p.first), varlist))
				for k in eachindex(points_ics)
					delete!(points_ics[k], p.first)
					delete!(ordered_test_points[k], p.first)
					delete!(parameter_values, p.first)
				end
				unident_dict[p.first] = p.second
			else
				all_identified = true
			end
		else
			all_identified = true
		end
	end
	println("Finally, the following substitutions will be made:", unident_dict)

	max_rank = rank(evaluated_jac, rtol = rtol)
	maxn = n
	while (n > 0)
		n = n - 1
		deriv_level = Dict([p => n for p in 1:length(measured_quantities)])
		reduced_evaluated_jac = multipoint_deriv_level_view(evaluated_jac, deriv_level, length(measured_quantities), max_num_points, maxn, max_num_points)
		r = rank(reduced_evaluated_jac, rtol = rtol)
		if (r < max_rank)
			n = n + 1
			deriv_level = Dict([p => n for p in 1:length(measured_quantities)])
			break
		end
	end

	keep_looking = true
	while (keep_looking)
		improvement_found = false
		sorting = collect(deriv_level)
		sorting = sort(sorting, by = (x -> x[2]), rev = true)
		for i in keys(deriv_level)
			if (deriv_level[i] > 0)
				deriv_level[i] = deriv_level[i] - 1
				reduced_evaluated_jac = multipoint_deriv_level_view(evaluated_jac, deriv_level, length(measured_quantities), max_num_points, maxn, max_num_points)

				r = rank(reduced_evaluated_jac, rtol = rtol)
				if (r < max_rank)
					deriv_level[i] = deriv_level[i] + 1
				else
					improvement_found = true
					break
				end
			else
				temp = pop!(deriv_level, i)
				reduced_evaluated_jac = multipoint_deriv_level_view(evaluated_jac, deriv_level, length(measured_quantities), max_num_points, maxn, max_num_points)

				r = rank(reduced_evaluated_jac, rtol = rtol)
				if (r < max_rank)
					deriv_level[i] = temp
				else
					improvement_found = true
					break
				end
			end
		end
		keep_looking = improvement_found
	end
	return (deriv_level, unident_dict, varlist, DD)
end


"""
	construct_equation_system(model::ODESystem, measured_quantities_in, data_sample,
							  deriv_level, unident_dict, varlist, DD, time_index_set = nothing, return_parameterized_system = false)

Construct an equation system for parameter estimation.

# Arguments
- `model::ODESystem`: The ODE system
- `measured_quantities_in`: Input measured quantities
- `data_sample`: Sample data
- `deriv_level`: Dictionary of derivative levels
- `unident_dict`: Dictionary of unidentifiable variables
- `varlist`: List of variables
- `DD`: DerivativeData object
- `time_index_set`: Set of time indices (optional)
- `return_parameterized_system`: Whether to return a parameterized system (optional, default: false)

# Returns
- Tuple containing the target equations and variable list
"""
function construct_equation_system(model::ODESystem, measured_quantities_in, data_sample,
	deriv_level, unident_dict, varlist, DD, time_index_set = nothing, return_parameterized_system = false)  #return_parameterized_system not supported yet

	measured_quantities = deepcopy(measured_quantities_in)
	(t, model_eq, model_states, model_ps) = unpack_ODE(model)
	D = Differential(t)

	t_vector = pop!(data_sample, "t")
	time_interval = (minimum(t_vector), maximum(t_vector))
	if (isnothing(time_index_set))
		time_index_set = [fld(length(t_vector), 2)]  #TODO add vector handling 
	end
	time_index = time_index_set[1]

	interpolants = Dict()
	for j in measured_quantities
		r = j.rhs
		y_vector = data_sample[r]
		interpolants[r] = aaad(t_vector, y_vector)
	end

	#handle unidentifiable variables, just substituting for them
	unident_subst!(model_eq, measured_quantities, unident_dict)

	max_deriv = max(4, 1 + maximum(collect(values(deriv_level))))

	#We begin building a system of equations which will be solved, e.g. by homotopoy continuation.
	#the first set of equations, built below, constrains the observables values and their derivatives 
	#to values determined by interpolation.
	target = []  # TODO give this a type later
	for (key, value) in deriv_level  # 0 means include the observation itself, 1 means first derivative
		push!(target, DD.obs_rhs_cleared[1][key] - DD.obs_lhs_cleared[1][key])
		for i in 1:value
			push!(target, DD.obs_rhs_cleared[i+1][key] - DD.obs_lhs_cleared[i+1][key])
		end
	end
	interpolated_values_dict = Dict()
	for (key, value) in deriv_level
		interpolated_values_dict[DD.obs_lhs[1][key]] =
			nth_deriv_at(interpolants[ModelingToolkit.diff2term(measured_quantities[key].rhs)], 0, t_vector[time_index])
		for i in 1:value
			interpolated_values_dict[DD.obs_lhs[i+1][key]] =
				nth_deriv_at(interpolants[ModelingToolkit.diff2term(measured_quantities[key].rhs)], i, t_vector[time_index])
		end
	end

	#if (!return_parameterized_system)
	for i in eachindex(target)
		target[i] = substitute(target[i], interpolated_values_dict)
	end
	#end

	#Now, we scan for state variables and their derivatives we need values for.
	#We add precisely the state variables we need and no more.
	#This forces the system to be square.
	vars_needed = OrderedSet()
	vars_added = OrderedSet()

	vars_needed = union(vars_needed, model_ps)
	vars_needed = union(vars_needed, model_states)
	vars_needed = setdiff(vars_needed, keys(unident_dict))

	keep_adding = true
	while (keep_adding)
		added = false
		for i in target
			for j in Symbolics.get_variables(i)
				push!(vars_needed, j)
			end
		end

		for i in setdiff(vars_needed, vars_added)
			for j in eachindex(DD.states_lhs), k in eachindex(DD.states_lhs[j])
				if (isequal(DD.states_lhs[j][k], i))
					push!(target, DD.states_lhs_cleared[j][k] - DD.states_rhs_cleared[j][k])
					added = true
					push!(vars_added, i)
				end
			end
		end
		diff_set = setdiff(vars_needed, vars_added)
		keep_adding = !isempty(diff_set) && added
	end

	push!(data_sample, ("t" => t_vector)) #TODO(orebas) maybe don't pop this in the first place


	return_var = collect(vars_needed)

	return target, return_var

end



"""
	squarify_by_trashing(poly_system, varlist, rtol = 1e-12)

Make a polynomial system square by removing equations.

# Arguments
- `poly_system`: Polynomial system to squarify
- `varlist`: List of variables
- `rtol`: Relative tolerance (default: 1e-12)

# Returns
- Tuple containing the new system, variable list, and trashed equations
"""
function squarify_by_trashing(poly_system, varlist, rtol = 1e-12)
	mat = ModelingToolkit.jacobian(poly_system, varlist)
	vsubst = Dict([p => rand(Float64) for p in varlist])
	numerical_mat = Matrix{Float64}(Symbolics.value.((substitute.(mat, Ref(vsubst)))))
	target_rank = rank(numerical_mat, rtol = rtol)
	currentlist = 1:length(poly_system)
	trashlist = []
	keep_looking = true
	while (keep_looking)
		improvement_found = false
		for j in currentlist
			newlist = filter(x -> x != j, currentlist)
			jac_view = view(numerical_mat, newlist, :)
			rank2 = rank(jac_view, rtol = rtol)
			if (rank2 == target_rank)
				improvement_found = true
				currentlist = newlist
				push!(trashlist, j)
				break
			end
		end
		keep_looking = improvement_found
	end
	new_system = [poly_system[i] for i in currentlist]
	trash_system = [poly_system[i] for i in trashlist]

	#println("we trash these: (line 708)")
	#display(trash_system)

	return new_system, varlist, trash_system
end


"""
	pick_points(vec, n)

Select n points from a vector, trying to spread them out.
TODO:  this can be improved, taking the measured_data into account
TODO:  actually, for now, it's just random (and therefore nondeterministic)
I haven't tested this (i.e. justified it), but by default, we avoid the endpoints.
n is assumed to be less than length(vec)

# Arguments
- `vec`: Vector to pick points from
- `n`: Number of points to pick

# Returns
- Vector of selected indices
"""
function pick_points(vec, n)
	if (n == length(vec))
		return 1:n
	elseif (n == length(vec) - 1)
		return 1:(n-1)
	elseif (n == length(vec) - 2)
		return 2:(n-1)
	else
		l = length(vec)
		perm = randperm(l - 2) .+ 1
		reduced = perm[1:n]
		#res = [ [1] ; reduced ; [l]]
		sort!(reduced)
		return reduced
	end
end


"""
	MPHCPE(model::ODESystem, measured_quantities, data_sample, ode_solver; system_solver = solveJSwithHC, display_points = true, max_num_points = 4)

Perform Multi-point Homotopy Continuation Parameter Estimation.

# Arguments
- `model::ODESystem`: The ODE system
- `measured_quantities`: Measured quantities
- `data_sample`: Sample data
- `ode_solver`: ODE solver to use
- `system_solver`: System solver function (optional, default: solveJSwithHC)
- `display_points`: Whether to display points (optional, default: true)
- `max_num_points`: Maximum number of points to use (optional, default: 4)

# Returns
- Vector of result vectors
"""
function MPHCPE(model::ODESystem, measured_quantities, data_sample, ode_solver; system_solver = solveJSwithHC, display_points = true, max_num_points = 4)
	t = ModelingToolkit.get_iv(model)
	model_eq = ModelingToolkit.equations(model)
	model_states = ModelingToolkit.unknowns(model)
	model_ps = ModelingToolkit.parameters(model)

	t_vector = data_sample["t"]
	time_interval = (minimum(t_vector), maximum(t_vector))
	found_any_solutions = false
	large_num_points = min(length(model_ps), max_num_points, length(t_vector)) + 1
	good_num_points = large_num_points
	time_index_set = []
	solns = []
	good_udict = []
	forward_subst_dict = []
	trivial_dict = []
	final_varlist = []
	trimmed_varlist = []
	while (!found_any_solutions)
		good_num_points = good_num_points - 1
		(target_deriv_level, target_udict, target_varlist, target_DD) = multipoint_local_identifiability_analysis(model, measured_quantities, large_num_points)
		while (good_num_points > 1)
			good_num_points = good_num_points - 1
			(test_deriv_level, test_udict, test_varlist, test_DD) = multipoint_local_identifiability_analysis(model, measured_quantities, good_num_points)
			if !(test_deriv_level == target_deriv_level)
				good_num_points = good_num_points + 1
				break
			end
		end
		(good_deriv_level, good_udict, good_varlist, good_DD) = multipoint_local_identifiability_analysis(model, measured_quantities, good_num_points)

		time_index_set = pick_points(t_vector, good_num_points)
		if (display_points)
			println("We are trying these points:", time_index_set)
			println("Using these observations and their derivatives:")
			display(good_deriv_level)
		end
		full_target = []
		full_varlist = []
		forward_subst_dict = []
		reverse_subst_dict = []
		@variables testing
		for k in time_index_set
			(target_k, varlist_k) = construct_equation_system(model, measured_quantities, data_sample, good_deriv_level, good_udict, good_varlist, good_DD, [k])
			local_subst_dict = OrderedDict{Num, Any}()
			local_subst_dict_reverse = OrderedDict()
			subst_var_list = []

			for i in eachindex(good_DD.states_lhs), j in eachindex(good_DD.states_lhs[i])
				push!(subst_var_list, good_DD.states_lhs[i][j])
			end
			for i in eachindex(model_states)
				push!(subst_var_list, model_states[i])
			end
			for i in eachindex(good_DD.obs_lhs), j in eachindex(good_DD.obs_lhs[i])
				push!(subst_var_list, good_DD.obs_lhs[i][j])
			end
			for i in subst_var_list
				newname = tag_symbol(i, "_t" * string(k) * "_", "_")
				j = Symbolics.wrap(i)

				#newname = testing
				local_subst_dict[j] = newname
				local_subst_dict_reverse[newname] = j
			end
			for i in model_ps
				newname = tag_symbol(i, "_t" * string("p"), "_")
				j = Symbolics.wrap(i)
				local_subst_dict[j] = newname
				local_subst_dict_reverse[newname] = j

			end

			target_k_subst = substitute.(target_k, Ref(local_subst_dict))
			varlist_k_subst = substitute.(varlist_k, Ref(local_subst_dict)) #TODO maybe ask why this didn't work but didn't fail without broadcasting
			push!(full_target, target_k_subst)
			push!(full_varlist, varlist_k_subst)
			push!(forward_subst_dict, local_subst_dict)
			push!(reverse_subst_dict, local_subst_dict_reverse)
		end
		# println("full target")
		#display(full_target)

		final_target = reduce(vcat, full_target)
		final_varlist = collect(reduce(union!, OrderedSet.(full_varlist))) #does this even work





		solve_result, hcvarlist, trivial_dict, trimmed_varlist = system_solver(final_target, final_varlist)

		solns = solve_result
		if (!isempty(solns))
			found_any_solutions = true
		end
	end

	@named new_model = ODESystem(model_eq, t, model_states, model_ps)
	new_model = complete(new_model)
	lowest_time_index = min(time_index_set...)

	results_vec = []
	local_states_dict_all = []
	for soln_index in eachindex(solns)
		initial_conditions = [1e10 for s in model_states]
		parameter_values = [1e10 for p in model_ps]
		for i in eachindex(model_ps)
			if model_ps[i] in keys(good_udict)
				parameter_values[i] = good_udict[model_ps[i]]
			else

				param_search = forward_subst_dict[1][(model_ps[i])]
				if (param_search in keys(trivial_dict))
					parameter_values[i] = trivial_dict[param_search]
				else
					index = findfirst(isequal(param_search), final_varlist)
					parameter_values[i] = real(solns[soln_index][index]) #TODOdo we ignore the imaginary part?
				end
			end                                                   #what about other vars
		end

		for i in eachindex(model_states)
			if model_states[i] in keys(good_udict)
				initial_conditions[i] = good_udict[model_states[i]]

			else
				#println("line 596")
				#display(Symbolics.wrap(model_states[i]))
				#display(fullvarlist)
				#display(typeof(Symbolics.wrap(model_states[i])))
				#display(varlist[3])
				#display(typeof(varlist[3]))
				#println("line 856")
				#display(lowest_time_index)
				#display(forward_subst_dict[lowest_time_index])
				#display(Symbolics.wrap(model_states[i]))

				#display(reverse_subst_dict[1])
				model_state_search = forward_subst_dict[1][(model_states[i])]
				#				println("line 929")
				#				display(model_states[i])
				#				display(model_state_search)

				if (model_state_search in keys(trivial_dict))
					initial_conditions[i] = trivial_dict[model_state_search]
					#					display(trivial_dict[model_state_search])

				else
					index = findfirst(
						isequal(model_state_search),
						trimmed_varlist)
					#						display(solns[soln_index][index])

					#display(real(solns[soln_index][index]))
					initial_conditions[i] = real(solns[soln_index][index]) #see above
				end
			end
		end

		initial_conditions = Base.convert(Array{ComplexF64, 1}, initial_conditions)
		if (isreal(initial_conditions))
			initial_conditions = Base.convert(Array{Float64, 1}, initial_conditions)
		end


		parameter_values = Base.convert(Array{ComplexF64, 1}, parameter_values)
		if (isreal(parameter_values))
			parameter_values = Base.convert(Array{Float64, 1}, parameter_values)
		end
		tspan = (t_vector[lowest_time_index], t_vector[1])  #this is backwards

		new_model = complete(new_model)
		prob = ODEProblem(new_model, initial_conditions, tspan, Dict(ModelingToolkit.parameters(new_model) .=> parameter_values))

		ode_solution = ModelingToolkit.solve(prob, ode_solver, abstol = 1e-14, reltol = 1e-14)

		state_param_map = (Dict(x => replace(string(x), "(t)" => "")
								for x in ModelingToolkit.unknowns(model)))
		newstates = OrderedDict()
		for s in model_states
			newstates[s] = ode_solution[Symbol(state_param_map[s])][end]
		end
		push!(results_vec, [collect(values(newstates)); parameter_values])
	end

	return results_vec


end





export MPHCPE, HCPE, ODEPEtestwrapper, ParameterEstimationResult, sample_data, diag_solveJSwithHC
export ParameterEstimationProblem, analyze_parameter_estimation_problem, fillPEP
export create_ode_system, sample_problem_data, analyze_estimation_result

#later, disable output of the compile_workload

@recompile_invalidations begin
	@compile_workload begin
		@parameters a b
		@variables t x1(t) x2(t) y1(t) y2(t)
		D = Differential(t)
		states = [x1, x2]
		parameters = [a, b]

		@named model = ODESystem([
				D(x1) ~ -a * x2,
				D(x2) ~ b * x1,  #edited from 1/b
			], t, states, parameters)
		measured_quantities = [
			y1 ~ x1,
			y2 ~ x2]

		ic = [0.333, 0.667]
		p_true = [0.4, 0.8]

		model = complete(model)
		data_sample = sample_data(model, measured_quantities, [-1.0, 1.0], p_true, ic, 19, solver = Vern9())

		ret = ODEPEtestwrapper(model, measured_quantities, data_sample, Vern9())

		display(ret)
	end
end


end

================
File: src/SharedUtils.jl
================
#module SharedUtils

using ModelingToolkit
#using DifferentialEquations
using OrderedCollections
using ODEParameterEstimation


struct ParameterEstimationProblem
    name::String
    model::ODESystem
    measured_quantities::Vector{Equation}
    data_sample::Union{Nothing, OrderedDict}
    solver::Any
    p_true::Vector{Float64}
    ic::Vector{Float64}
    unident_count::Int
end

function create_ode_system(name, states, parameters, equations, measured_quantities)
    @named model = ODESystem(equations, t, states, parameters)
    return model, measured_quantities
end

function sample_problem_data(problem::ParameterEstimationProblem; datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9())
    return ParameterEstimationProblem(
        problem.name,
        complete(problem.model),
        problem.measured_quantities,
        ODEParameterEstimation.sample_data(problem.model, problem.measured_quantities, time_interval, problem.p_true, problem.ic, datasize, solver = solver),
        solver,
        problem.p_true,
        problem.ic,
        problem.unident_count
    )
end

function analyze_estimation_result(problem::ParameterEstimationProblem, result)
    all_params = vcat(problem.ic, problem.p_true)
    besterror = Inf
    
    for each in result
        estimates = vcat(collect(values(each.states)), collect(values(each.parameters)))
        errorvec = abs.((estimates .- all_params) ./ all_params)
        
        if problem.unident_count > 0
            sort!(errorvec)
            for i in 1:problem.unident_count
                pop!(errorvec)
            end
        end
        
        besterror = min(besterror, maximum(errorvec))
    end
    
    println("For model $(problem.name): The max abs rel. err: $besterror")
    return besterror
end

================
File: src/bary_derivs.jl
================
"""
	rational_interpolation_coefficients(x, y, n)
CODE COPIED FROM previous version of ParameterEstimation.jl
Perform a rational interpolation of the data `y` at the points `x` with numerator degree `n`.
This function only returns the coefficients of the numerator and denominator polynomials.

# Arguments
- `x`: the points where the data is sampled (e.g. time points).
- `y`: the data sample.
- `n`: the degree of the numerator.

# Returns
- `c`: the coefficients of the numerator polynomial.
- `d`: the coefficients of the denominator polynomial.
"""
function rational_interpolation_coefficients(x, y, n)
	N = length(x)
	m = N - n - 1
	A = zeros(N, N)
	if m > 0
		A_left_submatrix = reduce(hcat, [x .^ (i) for i in 0:(n)])
		A_right_submatrix = reduce(hcat, [x .^ (i) for i in 0:(m-1)])
		A = hcat(A_left_submatrix, -y .* A_right_submatrix)
		b = y .* (x .^ m)
		try
			prob = LinearSolve.LinearProblem(A, b)
			c = LinearSolve.solve(prob)
			return c[1:(n+1)], [c[(n+2):end]; 1]
		catch SingularException
			lu_res = lu(A)
			y = lu_res.L \ lu_res.P * b
			c = lu_res.U \ y
			return c[1:(n+1)], [c[(n+2):end]; 1]
		end

	else
		A = reduce(hcat, [x .^ i for i in 0:n])
		b = y
		prob = LinearSolve.LinearProblem(A, b)
		c = LinearSolve.solve(prob)
		return c, [1]
	end
end





######### TODO(orebas)  REFACTOR into bary_derivs or something similiar
#to use the below, you can just pass vectors of xvalues and yvalues like so:
#F = aaad(xdata, ydata)
#and then F will be a callable, i.e. F(0.5) should work.  Let's please restrict to real xdata, and if so it should be sorted.  F is only defined in the range of the xvalues.

#To construct a derivative, you can do
#derivf(z) = ForwardDiff.derivative(F, z)
#I hope and suspect that other AD frameworks should work as well.

function baryEval(z, f::Vector{T}, x::Vector{T}, w::Vector{T}, tol = 1e-13) where {T}
	@assert(length(f) == length(x) == length(w))
	num = zero(T)
	den = zero(T)
	breakflag = false
	breakindex = -1
	for j in eachindex(f)
		t = w[j] / (z - x[j])
		num += t * f[j]
		den += t
		if ((z - x[j])^2 < sqrt(tol))
			breakflag = true
			breakindex = j
		end
	end
	fz = num / den
	if (breakflag)
		num = zero(T)
		den = zero(T)
		for j in eachindex(f)
			if (j != breakindex)
				t = w[j] / (z - x[j])
				num += t * f[j]
				den += t
			end
		end
		m = z - x[breakindex]
		fz = (w[breakindex] * f[breakindex] + m * num) / (w[breakindex] + m * den)
	end
	return fz
end

struct AAADapprox{T}
	internalAAA::T
end

struct FHDapprox{T}
	internalFHD::T
end

(y::FHDapprox)(z) = baryEval(z, y.internalFHD.f, y.internalFHD.x, y.internalFHD.w)
(y::AAADapprox)(z) = baryEval(z, y.internalAAA.f, y.internalAAA.x, y.internalAAA.w)

function nth_deriv_at_deprecated(f, n::Int, t)  #todo(orebas) make this more efficient.
	if (n == 0)
		return f(t)
	elseif (n == 1)
		return ForwardDiff.derivative(f, t)
	else
		g(t) = nth_deriv_at(f, n - 1, t)
		return ForwardDiff.derivative(g, t)
	end
end


function nth_deriv_at(f, n::Int, t)  #todo(orebas) make this more efficient.
	if (n == 0)
		return f(t)
	else
		return TaylorDiff.derivative(f, t, n)
	end
end


function aaad(xs::AbstractArray{T}, ys::AbstractArray{T}) where {T}
	#@suppress begin
		@assert length(xs) == length(ys)
		internalApprox = BaryRational.aaa(xs, ys,verbose=false)
		return AAADapprox(internalApprox)
	#end
end



function fhd(xs::AbstractArray{T}, ys::AbstractArray{T}, N::Int) where {T}
	#@suppress begin
		@assert length(xs) == length(ys)
		internalApprox = BaryRational.FHInterp(xs, ys, order = N, verbose = false)
		return FHDapprox(internalApprox)
	#end
end

function fhdn(n)
	fh(xs, ys) = fhd(xs, ys, n)
	return fh
end


####################

struct FourierSeries
	m::Any
	b::Any
	K::Any
	cosines::Any
	sines::Any
end


function fourierEval(x, FS)
	z = FS.m * x + FS.b
	sum = 0.0
	for k in eachindex(FS.cosines)
		sum += FS.cosines[k] * cos((k) * z)
	end
	for k in eachindex(FS.sines)
		sum += FS.sines[k] * sin((k) * z)
	end
	sum += FS.K
	return sum
end

(y::FourierSeries)(z) = fourierEval(z, y)



function FourierInterp(xs, ys)
	@assert length(xs) == length(ys)
	N = length(xs)
	width = xs[end] - xs[begin]
	m = pi / width
	b = -pi * (xs[begin] / width + 0.5)
	f(t) = m * t + b
	scaledxs = f.(xs)
	sinescount = (N - 1) ÷ 2
	cosinescount = N - 1 - sinescount
	A = zeros(Float64, N, N)
	for i ∈ 1:N, j ∈ 1:N
		if (j == 1)
			A[i, 1] = 1
		elseif (j <= (cosinescount + 1))
			A[i, j] = cos((j - 1) * scaledxs[i])
		else
			temp = (j - cosinescount - 1)
			A[i, j] = sin(temp * scaledxs[i])
		end
	end

	prob = LinearProblem(A, ys, LinearSolve.OperatorCondition.VeryIllConditioned)
	sol = LinearSolve.solve(prob)
	X = sol.u
	temp = FourierSeries(m, b, X[begin], X[2:(cosinescount+1)], X[(cosinescount+2):end])
	return temp
end



struct BaryLagrange{T <: AbstractArray}
	x::T
	f::T
	w::T
end

function BarycentricLagrange(xs, ys)
	@assert length(xs) == length(ys)
	N = length(xs)
	w = ones(Float64, N)
	for k in eachindex(xs)
		for j in eachindex(xs)
			if (k != j)
				w[k] *= (xs[k] - xs[j])
			end
		end
		w[k] = 1 / w[k]
	end
	return BaryLagrange(xs, ys, w)
end

(y::BaryLagrange)(z) = baryEval(z, y.f, y.x, y.w)

struct RationalFunction{T <: AbstractArray}
	a::T
	b::T
end

(y::RationalFunction)(z) = rationaleval(z, y.a, y.b)
rationaleval(z, a, b) = evalpoly(z, a) / evalpoly(z, b)



function simpleratinterp(xs, ys, d1::Int)
	@assert length(xs) == length(ys)
	N = length(xs)
	d2 = N - d1 - 1
	A = zeros(Float64, N, N)
	for j in 1:N
		A[j, 1] = 1
		for k in 1:d1
			A[j, k+1] = xs[j]^k
		end
		for k in 1:d2
			A[j, d1+1+k] = -1.0 * ys[j] * xs[j]^k
		end
	end
	prob = LinearProblem(A, ys, LinearSolve.OperatorCondition.VeryIllConditioned)
	sol = LinearSolve.solve(prob)
	X = sol.u
	return RationalFunction(
		X[1:(d1+1)],
		[1; X[(d1+2):end]])
end






function betterratinterp(xs, ys, d1::Int)
	@assert length(xs) == length(ys)
	N = length(xs)
	(c, d) = rational_interpolation_coefficients(xs, ys, d1)
	return RationalFunction(c, d)
end



function SimpleRationalInterp(numerator_degree::Int)
	f(xs, ys) = simpleratinterp(xs, ys, numerator_degree)
	return f
end

function SimpleRationalInterpOld(numerator_degree::Int)
	f(xs, ys) = betterratinterp(xs, ys, numerator_degree)
	return f
end


function default_interpolator(datasize)
	interpolators = Dict(
			"AAA" => aaad,
			"FHD3" => fhdn(3),
			#			"Fourier" => FourierInterp,
			#			"BaryLagrange" => BarycentricLagrange,
		)
		if (datasize > 10)
			interpolators["FHD8"] = fhdn(8)
			#			interpolators["FHD6"] = fhdn(6)
			#stepsize = max(1, datasize ÷ 4)
			#for i in range(1, (datasize - 2), step = stepsize)
			#	interpolators["RatOld($i)"] = SimpleRationalInterpOld(i)
			#end
		end
return interpolators
end

================
File: src/equation_solvers.jl
================
function solveJSwithMonodromy(poly_system, varlist)
	mangled_varlist = deepcopy(varlist)
	manglingDict = OrderedDict()
	len = length(poly_system)

	for i in eachindex(varlist)
		newvarname = Symbol("_z_" * replace(string(varlist[i]), "(t)" => "_t") * "_d")
		newvar = (@variables $newvarname)[1]
		mangled_varlist[i] = newvar
		manglingDict[Symbolics.unwrap(varlist[i])] = newvar
	end
	for i in eachindex(poly_system)
		poly_system[i] = Symbolics.substitute(Symbolics.unwrap(poly_system[i]), manglingDict)

	end
	string_target = string.(poly_system)
	varlist = mangled_varlist
	string_string_dict = Dict()
	var_string_dict = Dict()
	var_dict = Dict()
	hcvarlist = Vector{HomotopyContinuation.ModelKit.Variable}()


	for v in varlist
		vhcs = string(v)
		vhcslong = "hmcs(\"" * vhcs * "\")"

		var_string_dict[v] = vhcs
		vhc = HomotopyContinuation.ModelKit.Variable(Symbol(vhcs))
		var_dict[v] = vhc
		string_string_dict[string(v)] = vhcslong
		push!(hcvarlist, vhc)
	end
	for i in eachindex(string_target)
		string_target[i] = replace(string_target[i], string_string_dict...)
	end
	#display(string_target)
	parsed = eval.(Meta.parse.(string_target))
	@var _mpm[1:len] _mpc[1:len]
	paramlist = Vector{HomotopyContinuation.ModelKit.Variable}()
	for i in 1:len
		#push!(paramlist, _mpm[i])
		push!(paramlist, _mpc[i])
	end
	for i in eachindex(parsed)
		parsed[i] = parsed[i] - _mpc[i]
	end
	HomotopyContinuation.set_default_compile(:all)    #TODO test whether this helps or not
	F = HomotopyContinuation.System(parsed, variables = hcvarlist, parameters = paramlist)

	#param_final = repeat([1, 0], outer = len)
	param_final = repeat([0.0], outer = len)
	found_start_pair = false
	pair_attempts = 0
	newx = nothing
	while (!found_start_pair && pair_attempts < 50)  #lots of magic numbers in this section:  20, 5000, 3
		#println("is this a start pair? line 824")
		testx, testp = HomotopyContinuation.find_start_pair(F)
		#display(testx)
		#display(testp)

		#println("hopefully, this is a good start pair:")
		newx = HomotopyContinuation.solve(F, testx, start_parameters = testp, target_parameters = param_final, tracker_options = TrackerOptions(automatic_differentiation = 3))
		#display(newx)
		startpsoln = solutions(newx)
		#display(startpsoln)
		#display(param_final)
		pair_attempts += 1
		if (!isempty(startpsoln))
			found_start_pair = true
		end
	end
	result = HomotopyContinuation.monodromy_solve(F, solutions(newx), param_final, show_progress = true, target_solutions_count = 5000, timeout = 120.0, tracker_options = TrackerOptions(automatic_differentiation = 3))#only_nonsingular = false  ,)


	#println("results")
	#display(F)
	#display(result)
	#display(HomotopyContinuation.real_solutions(result))
	solns = HomotopyContinuation.solutions(result)
	complex_flag = false
	#if isempty(solns)
	#	solns = solutions(result, only_nonsingular = false)
	#	complexflag = true
	#end
	if (isempty(solns))
		display("No solutions, failed.")
		return ([], [], [], [])
	end

	#display(solns)
	return solns, hcvarlist


end






function solveJSwithHC(input_poly_system, input_varlist, use_monodromy = true, display_system = false)  #the input here is meant to be a polynomial, or eventually rational, system of julia symbolics
	if (display_system)
		println("starting solveJSWithHC.  Here is the polynomial system:")
		display(input_poly_system)
		#print_element_types(poly_system)
		println("varlist")
		display(input_varlist)
		#print_element_types(varlist)
	end

	(poly_system, varlist, trivial_vars, trivial_dict) = handle_simple_substitutions(input_poly_system, input_varlist)

	poly_system, varlist, trash = squarify_by_trashing(poly_system, varlist)

	jsvarlist = deepcopy(varlist)
	if (display_system)
		println("after trivial subst")
		display(poly_system)
		display(varlist)
		display(trivial_dict)
	end
	solns = []
	hcvarlist = []
	if (use_monodromy)
		#println("using monodromy, line 917")
		solns, hcvarlist = solveJSwithMonodromy(poly_system, varlist)

	else

		mangled_varlist = deepcopy(varlist)
		manglingDict = OrderedDict()


		for i in eachindex(varlist)
			newvarname = Symbol("_z_" * replace(string(varlist[i]), "(t)" => "_t") * "_d")
			newvar = (@variables $newvarname)[1]
			mangled_varlist[i] = newvar
			manglingDict[Symbolics.unwrap(varlist[i])] = newvar
		end
		for i in eachindex(poly_system)
			poly_system[i] = Symbolics.substitute(Symbolics.unwrap(poly_system[i]), manglingDict)

		end
		string_target = string.(poly_system)
		varlist = mangled_varlist
		string_string_dict = Dict()
		var_string_dict = Dict()
		var_dict = Dict()
		hcvarlist = Vector{HomotopyContinuation.ModelKit.Variable}()

		#println("after mangling:")

		for v in varlist
			vhcs = string(v)
			vhcslong = "hmcs(\"" * vhcs * "\")"

			var_string_dict[v] = vhcs
			vhc = HomotopyContinuation.ModelKit.Variable(Symbol(vhcs))
			var_dict[v] = vhc
			string_string_dict[string(v)] = vhcslong
			push!(hcvarlist, vhc)
		end
		for i in eachindex(string_target)
			string_target[i] = replace(string_target[i], string_string_dict...)
		end
		#display(string_target)
		parsed = eval.(Meta.parse.(string_target))
		HomotopyContinuation.set_default_compile(:all)    #TODO test whether this helps or not
		F = HomotopyContinuation.System(parsed, variables = hcvarlist)
		#println("system we are solving (line 428)")
		result = HomotopyContinuation.solve(F, show_progress = true;) #only_nonsingular = false


		#println("results")
		#display(F)
		#display(result)
		#display(HomotopyContinuation.real_solutions(result))
		solns = HomotopyContinuation.real_solutions(result)
		complex_flag = false
		if isempty(solns)
			solns = solutions(result, only_nonsingular = false)
			complexflag = true
		end
	end

	if (isempty(solns))
		display("No solutions, failed.")
		return ([], [], [], [])
	end
	display(solns)
	return solns, hcvarlist, trivial_dict, jsvarlist
end



function discarded_solveJSwithHC(input_poly_system, input_varlist)  #the input here is meant to be a polynomial, or eventually rational, system of julia symbolics
	#println("starting SolveJSWithHC.  Here is the polynomial system:")
	#display(input_poly_system)
	#print_element_types(poly_system)
	#println("varlist")
	#display(input_varlist)
	#print_element_types(varlist)


	(poly_system, varlist, trivial_vars, trivial_dict) = handle_simple_substitutions(input_poly_system, input_varlist)

	poly_system, varlist, trash = squarify_by_trashing(poly_system, varlist)

	jsvarlist = deepcopy(varlist)
	#println("after trivial subst")
	#display(poly_system)
	#display(varlist)
	#display(trivial_dict)

	mangled_varlist = deepcopy(varlist)
	manglingDict = OrderedDict()


	for i in eachindex(varlist)
		newvarname = Symbol("_z_" * replace(string(varlist[i]), "(t)" => "_t") * "_d")
		newvar = (@variables $newvarname)[1]
		mangled_varlist[i] = newvar
		manglingDict[Symbolics.unwrap(varlist[i])] = newvar
	end
	for i in eachindex(poly_system)
		poly_system[i] = Symbolics.substitute(Symbolics.unwrap(poly_system[i]), manglingDict)

	end
	string_target = string.(poly_system)
	varlist = mangled_varlist
	string_string_dict = Dict()
	var_string_dict = Dict()
	var_dict = Dict()
	hcvarlist = Vector{HomotopyContinuation.ModelKit.Variable}()

	#println("after mangling:")

	for v in varlist
		vhcs = string(v)
		vhcslong = "hmcs(\"" * vhcs * "\")"

		var_string_dict[v] = vhcs
		vhc = HomotopyContinuation.ModelKit.Variable(Symbol(vhcs))
		var_dict[v] = vhc
		string_string_dict[string(v)] = vhcslong
		push!(hcvarlist, vhc)
	end
	for i in eachindex(string_target)
		string_target[i] = replace(string_target[i], string_string_dict...)
	end
	#display(string_target)
	parsed = eval.(Meta.parse.(string_target))
	HomotopyContinuation.set_default_compile(:all)    #TODO test whether this helps or not
	F = HomotopyContinuation.System(parsed, variables = hcvarlist)
	#println("system we are solving (line 428)")
	result = HomotopyContinuation.solve(F, show_progress = true;) #only_nonsingular = false


	#println("results")
	#display(F)
	#display(result)
	#display(HomotopyContinuation.real_solutions(result))
	solns = HomotopyContinuation.real_solutions(result)
	complex_flag = false
	if isempty(solns)
		solns = solutions(result, only_nonsingular = false)
		complexflag = true
	end
	if (isempty(solns))
		display("No solutions, failed.")
		return ([], [], [], [])
	end
	display(solns)
	return solns, hcvarlist, trivial_dict, jsvarlist
end

================
File: src/sample_data.jl
================
#This is a utility function which fills in observed data by solving an ODE.

function sample_data(model::ModelingToolkit.ODESystem,
	measured_data::Vector{ModelingToolkit.Equation},
	time_interval::Vector{T},
	p_true::Vector{T},
	u0::Vector{T},
	num_points::Int;
	uneven_sampling = false,
	uneven_sampling_times = Vector{T}(),
	solver = Vern9(), inject_noise = false, mean_noise = 0,
	stddev_noise = 1, abstol = 1e-14, reltol = 1e-14) where {T <: Number}
	if uneven_sampling
		if length(uneven_sampling_times) == 0
			error("No uneven sampling times provided")
		end
		if length(uneven_sampling_times) != num_points
			error("Uneven sampling times must be of length num_points")
		end
		sampling_times = uneven_sampling_times
	else
		sampling_times = range(time_interval[1], time_interval[2], length = num_points)
	end
	problem = ODEProblem(ModelingToolkit.complete(model), u0, time_interval, Dict(ModelingToolkit.parameters(model) .=> p_true))
	solution_true = ModelingToolkit.solve(problem, solver,
		saveat = sampling_times;
		abstol, reltol)
	data_sample = OrderedDict{Any, Vector{T}}(Num(v.rhs) => solution_true[Num(v.rhs)]
											  for v in measured_data)
	if inject_noise
		for (key, sample) in data_sample
			data_sample[key] = sample + randn(num_points) .* stddev_noise .+ mean_noise
		end
	end
	data_sample["t"] = sampling_times
	return data_sample
end

================
File: src/test_utils.jl
================
function fillPEP(pe::ParameterEstimationProblem; datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9(), add_noise = false)  #TODO add noise handling 

	return ParameterEstimationProblem(
		pe.Name,
		complete(pe.model),
		pe.measured_quantities,
		sample_data(pe.model, pe.measured_quantities, time_interval, pe.p_true, pe.ic, datasize, solver = solver),
		solver,
		pe.p_true,
		pe.ic,
		pe.unident_count)
end

function analyze_parameter_estimation_problem(PEP::ParameterEstimationProblem; test_mode = false, showplot = true, run_ode_pe = true)

	#interpolators = Dict(
	#	"AAA" => ParameterEstimation.aaad,
	#"FHD3" => ParameterEstimation.fhdn(3),
	#"FHD6" => ParameterEstimation.fhdn(6),
	#"FHD8" => ParameterEstimation.fhdn(8),
	#"Fourier" => ParameterEstimation.FourierInterp,
	#)
	datasize = 21 #TODO(Orebas) magic number

	#stepsize = max(1, datasize ÷ 8)
	#for i in range(1, (datasize - 2), step = stepsize)
	#	interpolators["RatOld($i)"] = ParameterEstimation.SimpleRationalInterpOld(i)
	#end

	#@time res = ParameterEstimation.estimate(PEP.model, PEP.measured_quantities,
	#	PEP.data_sample,
	#	solver = PEP.solver, disable_output = false, interpolators = interpolators)
	#all_params = vcat(PEP.ic, PEP.p_true)
	#println("TYPERES: ", typeof(res))
	#println(res)

	#println(res)
	besterror = 1e30
	all_params = vcat(PEP.ic, PEP.p_true)

	if (run_ode_pe)
		println("Starting model: ", PEP.Name)
		@time PEP.Name res3 = ODEPEtestwrapper(PEP.model, PEP.measured_quantities,
			PEP.data_sample,
			PEP.solver,
		)
		besterror = 1e30
		res3 = sort(res3, by = x -> x.err)
		display("How close are we?")
		println("Actual values:")
		display(all_params)

		for each in res3

			estimates = vcat(collect(values(each.states)), collect(values(each.parameters)))
			if (each.err < 1)  #TODO: magic number

				display(estimates)
				println("Error: ", each.err)
			end

			errorvec = abs.((estimates .- all_params) ./ (all_params))
			if (PEP.unident_count > 0)
				sort!(errorvec)
				for i in 1:PEP.unident_count
					pop!(errorvec)
				end
			end
			besterror = min(besterror, maximum(errorvec))
		end

		if (test_mode)
			#@test besterror < 1e-1
		end
		println("For model ", PEP.Name, ": The ODEPE  max abs rel. err: ", besterror)
	end
end


"""
	ODEPEtestwrapper(model::ODESystem, measured_quantities, data_sample, ode_solver; system_solver = solveJSwithHC, abstol = 1e-12, reltol = 1e-12, max_num_points = 4)

Wrapper function for testing ODE Parameter Estimation.

# Arguments
- `model::ODESystem`: The ODE system
- `measured_quantities`: Measured quantities
- `data_sample`: Sample data
- `ode_solver`: ODE solver to use
- `system_solver`: System solver function (optional, default: solveJSwithHC)
- `abstol`: Absolute tolerance (optional, default: 1e-12)
- `reltol`: Relative tolerance (optional, default: 1e-12)
- `max_num_points`: Maximum number of points to use (optional, default: 4)

# Returns
- Vector of ParameterEstimationResult objects
"""
function ODEPEtestwrapper(model::ODESystem, measured_quantities, data_sample, ode_solver; system_solver = solveJSwithHC, abstol = 1e-12, reltol = 1e-12, max_num_points = 4)

	model_states = ModelingToolkit.unknowns(model)
	model_ps = ModelingToolkit.parameters(model)
	tspan = (data_sample["t"][begin], data_sample["t"][end])

	param_dict  = Dict(model_ps .=> ones(length(model_ps)))
	states_dict = Dict(model_states .=> ones(length(model_states)))

	solved_res = []
	newres = ParameterEstimationResult(param_dict,
		states_dict, tspan[1], nothing, nothing, length(data_sample["t"]), tspan[1])
	results_vec = MPHCPE(model, measured_quantities, data_sample, ode_solver, system_solver = system_solver, max_num_points = max_num_points)

	for each in results_vec
		push!(solved_res, deepcopy(newres))


		for (key, value) in solved_res[end].parameters
			solved_res[end].parameters[key] = 1e30
		end
		for (key, value) in solved_res[end].states
			solved_res[end].states[key] = 1e30
		end
		#println(newres)
		i = 1
		for (key, value) in solved_res[end].states
			solved_res[end].states[key] = each[i]
			i += 1
		end


		for (key, value) in solved_res[end].parameters
			solved_res[end].parameters[key] = each[i]
			i += 1
		end
		ic = deepcopy(solved_res[end].states)
		ps = deepcopy(solved_res[end].parameters)
		prob = ODEProblem(complete(model), ic, tspan, ps)

		ode_solution = ModelingToolkit.solve(prob, ode_solver, saveat = data_sample["t"], abstol = abstol, reltol = reltol)
		err = 0
		if ode_solution.retcode == ReturnCode.Success
			err = 0
			for (key, sample) in data_sample
				if isequal(key, "t")
					continue
				end
				err += norm((ode_solution(data_sample["t"])[key]) .- sample) / length(data_sample["t"])
			end
			err /= length(data_sample)
		else
			err = 1e+15
		end
		solved_res[end].err = err


	end
	return solved_res
end

================
File: src/utils.jl
================
function unpack_ODE(model::ODESystem)
	return ModelingToolkit.get_iv(model), deepcopy(ModelingToolkit.equations(model)), ModelingToolkit.unknowns(model), ModelingToolkit.parameters(model)
end

#unident_dict is a dict of globally unidentifiable variables, and the substitution for them
#deriv_level is a dict of 
#(indices into measured_quantites =>   level of derivative to include)


#clear denominators on both sides of an equation of rational expressions
function clear_denoms(eq)
	@variables _qz_discard1 _qz_discard2
	expr_fake = Symbolics.value(simplify_fractions(_qz_discard1 / _qz_discard2)) #this is a gross way to get the operator for division.
	op = Symbolics.operation(expr_fake)

	ret = eq
	if (!isequal(eq.rhs, 0))
		expr = eq.rhs
		lexpr = eq.lhs
		expr2 = Symbolics.value(simplify_fractions(expr))
		if (istree(expr2) && Symbolics.operation(expr2) == op)
			numer, denom = Symbolics.arguments(expr2)
			ret = lexpr * denom ~ numer
		end
	end
	return ret
end

#this substitutes parameters that have been tagged as unidentifiable, by their presence in unident_dict.
function unident_subst!(model_eq, measured_quantities, unident_dict)
	for i in eachindex(model_eq)
		model_eq[i] = substitute(model_eq[i].lhs, unident_dict) ~ substitute(model_eq[i].rhs, unident_dict)
	end
	for i in eachindex(measured_quantities)
		measured_quantities[i] = substitute(measured_quantities[i].lhs, unident_dict) ~ substitute(measured_quantities[i].rhs, unident_dict)
	end
end


"""
	hmcs(x)

Convert a symbol to a HomotopyContinuation ModelKit Variable.

# Arguments
- `x`: Symbol to convert

# Returns
- HomotopyContinuation ModelKit Variable
"""
function hmcs(x)
	return HomotopyContinuation.ModelKit.Variable(Symbol(x))
end



function print_element_types(v)
	for elem in v
		println(typeof(elem))
	end
end

"""
	tag_symbol(thesymb, pre_tag, post_tag)

Add tags to a symbol.

# Arguments
- `thesymb`: Symbol to tag
- `pre_tag`: Tag to add before the symbol
- `post_tag`: Tag to add after the symbol

# Returns
- New tagged symbol
"""
function tag_symbol(thesymb, pre_tag, post_tag)
	newvarname = Symbol(pre_tag * replace(string(thesymb), "(t)" => "_t") * post_tag)
	return (@variables $newvarname)[1]
end

================
File: test/Project.toml
================
[deps]
BaryRational = "91aaffc3-5777-4842-85b7-5d3d5d6a3494"
DifferentialEquations = "0c46a032-eb83-5123-abaf-570d42b7fbaa"
HomotopyContinuation = "f213a82b-91d6-5c5d-acf7-10f1c761b327"
ModelingToolkit = "961ee093-0014-501f-94e3-6117800e7a78"
OrderedCollections = "bac558e1-5e72-5ebc-8fee-abe8a469f55d"
TaylorDiff = "b36ab563-344f-407b-a36a-4f200bebf99c"
Test = "8dfed614-e22c-5e08-85e1-65c5234f0b40"
TestSetExtensions = "98d24dd4-01ad-11ea-1b02-c9a08f80db04"

================
File: test/runtests.jl
================
using ODEParameterEstimation
using Test
using ModelingToolkit
using HomotopyContinuation
using DifferentialEquations
using OrderedCollections
#using ParameterEstimation



struct ParameterEstimationProblem
	Name::Any
	model::Any
	measured_quantities::Any
	data_sample::Any
	solver::Any
	p_true::Any
	ic::Any
	unident_count::Any
end

function fillPEP(pe::ParameterEstimationProblem; datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9())
	return ParameterEstimationProblem(
		pe.Name,
		complete(pe.model),
		pe.measured_quantities,
		sample_data(pe.model, pe.measured_quantities, time_interval, pe.p_true, pe.ic, datasize, solver = solver),
		solver,
		pe.p_true,
		pe.ic,
		pe.unident_count)

	return pe
end


function biohydrogenation()
	@parameters k5 k6 k7 k8 k9 k10
	@variables t x4(t) x5(t) x6(t) x7(t) y1(t) y2(t)
	D = Differential(t)
	states = [x4, x5, x6, x7]
	parameters = [k5, k6, k7, k8, k9, k10]

	@named model = ODESystem([
			D(x4) ~ -k5 * x4 / (k6 + x4),
			D(x5) ~ k5 * x4 / (k6 + x4) - k7 * x5 / (k8 + x5 + x6),
			D(x6) ~ k7 * x5 / (k8 + x5 + x6) - k9 * x6 * (k10 - x6) / k10,
			D(x7) ~ k9 * x6 * (k10 - x6) / k10,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x4,
		y2 ~ x5,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.143, 0.286, 0.429, 0.571, 0.714, 0.857]
	return ParameterEstimationProblem("BioHydrogenation",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 1)
end

function crauste()
	@parameters mu_N mu_EE mu_LE mu_LL mu_M mu_P mu_PE mu_PL delta_NE delta_EL delta_LM rho_E rho_P
	@variables t N(t) E(t) S(t) M(t) P(t) y1(t) y2(t) y3(t) y4(t)
	D = Differential(t)
	states = [N, E, S, M, P]
	parameters = [
		mu_N,
		mu_EE,
		mu_LE,
		mu_LL,
		mu_M,
		mu_P,
		mu_PE,
		mu_PL,
		delta_NE,
		delta_EL,
		delta_LM,
		rho_E,
		rho_P,
	]
	@named model = ODESystem(
		[
			D(N) ~ -N * mu_N - N * P * delta_NE,
			D(E) ~ N * P * delta_NE - E^2 * mu_EE -
				   E * delta_EL + E * P * rho_E,
			D(S) ~ S * delta_EL - S * delta_LM - S^2 * mu_LL -
				   E * S * mu_LE,
			D(M) ~ S * delta_LM - mu_M * M,
			D(P) ~ P^2 * rho_P - P * mu_P - E * P * mu_PE -
				   S * P * mu_PL,
		], t, states, parameters)
	measured_quantities = [y1 ~ N, y2 ~ E, y3 ~ S + M, y4 ~ P]

	ic = [0.167, 0.333, 0.5, 0.667, 0.833]
	p_true = [
		0.071,
		0.143,
		0.214,
		0.286,
		0.357,
		0.429,
		0.5,
		0.571,
		0.643,
		0.714,
		0.786,
		0.857,
		0.929,
	] # True Parameters

	return ParameterEstimationProblem("Crauste",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function daisy_ex3()
	@parameters p1 p3 p4 p6 p7
	@variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, u0]
	parameters = [p1, p3, p4, p6, p7]
	@named model = ODESystem([
			D(x1) ~ -1.0 * p1 * x1 + x2 + u0,
			D(x2) ~ p3 * x1 - p4 * x2 + x3,
			D(x3) ~ p6 * x1 - p7 * x3,
			D(u0) ~ 1.0,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ u0,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.167, 0.333, 0.5, 0.667, 0.833] # True Parameters


	return ParameterEstimationProblem("DAISY_ex3",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end



function daisy_ex3_v2()
	@parameters p1 p3 p4 p6 p7
	@variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, u0]
	parameters = [p1, p3, p4, p6, p7]
	@named model = ODESystem([
			D(x1) ~ -1.0 * p1 * x1 + x2 + u0,
			D(x2) ~ p3 * x1 - p4 * x2 + x3,
			D(x3) ~ p6 * x1 - p7 * x3,
			D(u0) ~ 1.0,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ u0,
	]

	ic = [1.0, 2.0, 1.0, 1.0]
	p_true = [0.2, 0.3, 0.5, 0.6, -0.2] # True Parameters



	return ParameterEstimationProblem("DAISY_ex3_v2",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end



function daisy_ex3_v3()
	@parameters p1 p3 p4 p6 p7 pd
	@variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, u0]
	parameters = [p1, p3, p4, p6, p7, pd]
	@named model = ODESystem([
			D(x1) ~ x2 + u0 - p1 * x1,
			D(x2) ~ p3 * x1 - p4 * x2 + x3,
			D(x3) ~ p6 * x1 - p7 * x3,
			D(u0) ~ pd,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ u0,
	]

	ic = [1.0, 2.0, 1.0, 1.0]
	p_true = [0.2, 0.3, 0.5, 0.6, -0.2, 1.0] # True Parameters

	return ParameterEstimationProblem("DAISY_ex3_v3",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end



function daisy_ex3_v4()
	@parameters p1 p3 p4 p6 p7 pd
	@variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, u0]
	parameters = [p1, p3, p4, p6, p7, pd]
	@named model = ODESystem([
			D(x1) ~ x2 + u0 - p1 * x1,
			D(x2) ~ p3 * x1 - p4 * x2 + x3,
			D(x3) ~ p6 * x1 - p7 * x3,
			D(u0) ~ pd,
		], t, states, parameters)
	measured_quantities = [y1 ~ x1 + x3, y2 ~ x2]


	ic = [1.0, 2.0, 1.0, 1.0]
	p_true = [0.2, 0.3, 0.5, 0.6, -0.2, 1.0] # True Parameters

	return ParameterEstimationProblem("DAISY_ex3_v4",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end






function daisy_mamil3(datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9())
	@parameters a12 a13 a21 a31 a01
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t)
	D = Differential(t)

	ic = [0.25, 0.5, 0.75]
	sampling_times = range(time_interval[1], time_interval[2], length = datasize)
	p_true = [0.167, 0.333, 0.5, 0.667, 0.833] # True Parameters

	states = [x1, x2, x3]
	parameters = [a12, a13, a21, a31, a01]
	@named model = ODESystem([D(x1) ~ -(a21 + a31 + a01) * x1 + a12 * x2 + a13 * x3,
			D(x2) ~ a21 * x1 - a12 * x2,
			D(x3) ~ a31 * x1 - a13 * x3],
		t, states, parameters)
	measured_quantities = [y1 ~ x1, y2 ~ x2]


	return ParameterEstimationProblem("DAISY_mamil3",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function daisy_mamil4(datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9())
	@parameters k01, k12, k13, k14, k21, k31, k41
	@variables t x1(t) x2(t) x3(t) x4(t) y1(t) y2(t) y3(t)
	D = Differential(t)

	ic = [0.2, 0.4, 0.6, 0.8]
	sampling_times = range(time_interval[1], time_interval[2], length = datasize)
	p_true = [0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875] # True Parameters

	states = [x1, x2, x3, x4]
	parameters = [k01, k12, k13, k14, k21, k31, k41]
	@named model = ODESystem([
			D(x1) ~ -k01 * x1 + k12 * x2 + k13 * x3 + k14 * x4 - k21 * x1 - k31 * x1 -
					k41 * x1,
			D(x2) ~ -k12 * x2 + k21 * x1,
			D(x3) ~ -k13 * x3 + k31 * x1,
			D(x4) ~ -k14 * x4 + k41 * x1],
		t, states, parameters)
	measured_quantities = [y1 ~ x1, y2 ~ x2, y3 ~ x3 + x4]


	return ParameterEstimationProblem("DAISY_mamil4",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function fitzhugh_nagumo()
	@parameters g a b
	@variables t V(t) R(t) y1(t) y2(t)
	D = Differential(t)
	states = [V, R]
	parameters = [g, a, b]

	ic = [0.333, 0.67]
	#sampling_times = range(time_interval[1], time_interval[2], length = datasize)
	p_true = [0.25, 0.5, 0.75] # True Parameters
	measured_quantities = [y1 ~ V]

	@named model = ODESystem([
			D(V) ~ g * (V - V^3 / 3 + R),
			D(R) ~ 1 / g * (V - a + b * R),
		], t, states, parameters)

	return ParameterEstimationProblem("fitzhugh-nagumo",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function hiv_local()
	@parameters b c d k1 k2 mu1 mu2 q1 q2 s
	@variables t x1(t) x2(t) x3(t) x4(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, x4]
	parameters = [b, c, d, k1, k2, mu1, mu2, q1, q2, s]

	@named model = ODESystem([	D(x1) ~ -b * x1 * x4 - d * x1 + s,	D(x2) ~ b * q1 * x1 * x4 - k1 * x2 - mu1 * x2,D(x3) ~ b * q2 * x1 * x4 + k1 * x2 - mu2 * x3,D(x4) ~ -c * x4 + k2 * x3,], t, states, parameters)
	measured_quantities = [ y1 ~ x1,  y2 ~ x4]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.091, 0.182, 0.273, 0.364, 0.455, 0.545, 0.636, 0.727, 0.818, 0.909]
	time_interval = [-0.5, 0.5]
	datasize = 20

	return ParameterEstimationProblem("hiv_local",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 8)  #todo:  should this be 7 or 8?
end

function hiv()
	@parameters lm d beta a k u c q b h
	@variables t x(t) y(t) v(t) w(t) z(t) y1(t) y2(t) y3(t) y4(t)
	D = Differential(t)
	states = [x, y, v, w, z]
	parameters = [lm, d, beta, a, k, u, c, q, b, h]

	@named model = ODESystem([
			D(x) ~ lm - d * x - beta * x * v,
			D(y) ~ beta * x * v - a * y,
			D(v) ~ k * y - u * v,
			D(w) ~ c * x * y * w - c * q * y * w - b * w,
			D(z) ~ c * q * y * w - h * z,
		], t, states, parameters)
	measured_quantities = [y1 ~ w, y2 ~ z, y3 ~ x, y4 ~ y + v]

	ic = [0.167, 0.333, 0.5, 0.667, 0.833]
	p_true = [0.091, 0.181, 0.273, 0.364, 0.455, 0.545, 0.636, 0.727, 0.818, 0.909]


	return ParameterEstimationProblem("hiv",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function lotka_volterra()
	@parameters k1 k2 k3
	@variables t r(t) w(t) y1(t)
	D = Differential(t)
	ic = [0.333, 0.667]
	p_true = [0.25, 0.5, 0.75] # True Parameters
	measured_quantities = [y1 ~ r]
	states = [r, w]
	parameters = [k1, k2, k3]

	@named model = ODESystem([
			D(r) ~ k1 * r - k2 * r * w,
			D(w) ~ k2 * r * w - k3 * w], t,
		states, parameters)

	return ParameterEstimationProblem("Lotka_Volterra", model, measured_quantities,
		:nothing, :nothing, p_true, ic, 0)
end

function seir()
	@parameters a b nu
	@variables t S(t) E(t) In(t) N(t) y1(t) y2(t)
	D = Differential(t)
	states = [S, E, In, N]
	parameters = [a, b, nu]

	@named model = ODESystem([
			D(S) ~ -b * S * In / N,
			D(E) ~ b * S * In / N - nu * E,
			D(In) ~ nu * E - a * In,
			D(N) ~ 0,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ In,
		y2 ~ N,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.25, 0.5, 0.75]

	return ParameterEstimationProblem("SEIR",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function simple()
	@parameters a b
	@variables t x1(t) x2(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2]
	parameters = [a, b]

	@named model = ODESystem([
			D(x1) ~ -a * x2,
			D(x2) ~ b * x1,  #edited from 1/b
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2]

	ic = [0.333, 0.667]
	p_true = [0.4, 0.8]

	return ParameterEstimationProblem("simple",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function sirsforced()
	@parameters b0 b1 g M mu nu
	@variables t i(t) r(t) s(t) x1(t) x2(t) y1(t) y2(t)
	D = Differential(t)
	states = [i, r, s, x1, x2]
	parameters = [b0, b1, g, M, mu, nu]

	@named model = ODESystem([
			D(i) ~ b0 * (1.0 + b1 * x1) * i * s - (nu + mu) * i,
			D(r) ~ nu * i - (mu + g) * r,
			D(s) ~ mu - mu * s - b0 * (1.0 + b1 * x1) * i * s + g * r,
			D(x1) ~ -M * x2,
			D(x2) ~ M * x1,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ i,
		y2 ~ r,
	]

	ic = [0.167, 0.333, 0.5, 0.667, 0.833]
	p_true = [0.143, 0.286, 0.429, 0.571, 0.714, 0.857]

	return ParameterEstimationProblem("sirsforced",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 3)
end

function slowfast()  # TODO(orebas):in the old code it was CVODE_BDF.  should we go back to that?
	#solver = CVODE_BDF()
	@parameters k1 k2 eB
	@variables t xA(t) xB(t) xC(t) eA(t) eC(t) y1(t) y2(t) y3(t) y4(t) #eA(t) eC(t)
	D = Differential(t)
	states = [xA, xB, xC, eA, eC]
	parameters = [k1, k2, eB]
	@named model = ODESystem([
			D(xA) ~ -k1 * xA,
			D(xB) ~ k1 * xA - k2 * xB,
			D(xC) ~ k2 * xB,
			D(eA) ~ 0,
			D(eC) ~ 0,
		], t, states, parameters)

	measured_quantities = [y1 ~ xC, y2 ~ eA * xA + eB * xB + eC * xC, y3 ~ eA, y4 ~ eC]
	ic = [0.166, 0.333, 0.5, 0.666, 0.833]
	p_true = [0.25, 0.5, 0.75] # True Parameters

	return ParameterEstimationProblem("slowfast",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end


function substr_test()
	@parameters a b beta
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t) y3(t)
	D = Differential(t)
	states = [x1, x2, x3]
	parameters = [a, b, beta]

	@named model = ODESystem([
			D(x1) ~ -a * x2,
			D(x2) ~ b * (x1),
			D(x3) ~ a * b * beta * b * a * x3,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2,
		y3 ~ x3,
	]

	ic = [2.0, 3.0, 4.0]
	p_true = [0.1, 0.2, 0.3]

	return ParameterEstimationProblem("substr_test",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end


function global_unident_test()
	@parameters a b c d
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3]
	parameters = [a, b, c, d]

	@named model = ODESystem([
			D(x1) ~ -a * x1,
			D(x2) ~ (b + c) * (x1),
			D(x3) ~ d * x1,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2,
	]

	ic = [2.0, 3.0, 4.0]
	p_true = [0.1, 0.2, 0.3, 0.4]

	return ParameterEstimationProblem("global_unident_test",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 4)

end


function sum_test()
	@parameters a b c d
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3]
	parameters = [a, b, c]

	@named model = ODESystem([
			D(x1) ~ -a * x1,
			D(x2) ~ b * (x2),
			D(x3) ~ c * (x1 + x2),
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x3,
	]

	ic = [2.0, 3.0, 4.0]
	p_true = [0.1, 0.2, 0.3]

	return ParameterEstimationProblem("sum_test",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 3)

end





function treatment(datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9())  #note the solver.  Vern9 apparently can't handle mass matrices
	@parameters a b d g nu
	@variables t In(t) N(t) S(t) Tr(t) y1(t) y2(t)
	D = Differential(t)
	states = [In, N, S, Tr]
	parameters = [a, b, d, g, nu]

	@named model = ODESystem([D(In) ~ b * S * In / N + d * b * S * Tr / N - (a + g) * In,
			D(N) ~ 0,
			D(S) ~ -b * S * In / N - d * b * S * Tr / N,
			D(Tr) ~ g * In - nu * Tr], t, states, parameters)
	measured_quantities = [
		y1 ~ Tr,
		y2 ~ N,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.167, 0.333, 0.5, 0.667, 0.833]

	return ParameterEstimationProblem("treatment",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 7)
end

function vanderpol()
	@parameters a b
	@variables t x1(t) x2(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2]
	parameters = [a, b]

	@named model = ODESystem([
			D(x1) ~ a * x2,
			D(x2) ~ -(x1) - b * (x1^2 - 1) * (x2),
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2,
	]

	ic = [0.333, 0.667]
	p_true = [0.4, 0.8]

	return ParameterEstimationProblem("vanderpol",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function analyze_parameter_estimation_problem(PEP::ParameterEstimationProblem; test_mode = false, showplot = true, run_ode_pe = true)

	#interpolators = Dict(
	#	"AAA" => ParameterEstimation.aaad,
	#"FHD3" => ParameterEstimation.fhdn(3),
	#"FHD6" => ParameterEstimation.fhdn(6),
	#"FHD8" => ParameterEstimation.fhdn(8),
	#"Fourier" => ParameterEstimation.FourierInterp,
	#)
	datasize = 21 #TODO(Orebas) magic number

	#stepsize = max(1, datasize ÷ 8)
	#for i in range(1, (datasize - 2), step = stepsize)
	#	interpolators["RatOld($i)"] = ParameterEstimation.SimpleRationalInterpOld(i)
	#end

	#@time res = ParameterEstimation.estimate(PEP.model, PEP.measured_quantities,
	#	PEP.data_sample,
	#	solver = PEP.solver, disable_output = false, interpolators = interpolators)
	#all_params = vcat(PEP.ic, PEP.p_true)
	#println("TYPERES: ", typeof(res))
	#println(res)

	#println(res)
	besterror = 1e30
	all_params = vcat(PEP.ic, PEP.p_true)

	if (run_ode_pe)
		res3 = ODEPEtestwrapper(PEP.model, PEP.measured_quantities,
			PEP.data_sample,
			PEP.solver)
		display("res3")
		display(res3)
		besterror = 1e30
		res3 = sort(res3, by = x -> x.err)
		display("How close are we?")
		println("Actual values:")
		display(all_params)

		for each in res3

			estimates = vcat(collect(values(each.states)), collect(values(each.parameters)))
			if (each.err < 100)  #TODO: magic number

				display(estimates)
				println("Error: ", each.err)
			end

			errorvec = abs.((estimates .- all_params) ./ (all_params))
			if (PEP.unident_count > 0)
				sort!(errorvec)
				for i in 1:PEP.unident_count
					pop!(errorvec)
				end
			end
			besterror = min(besterror, maximum(errorvec))
		end

		if (test_mode)
			@test besterror < 1e-1
		end
		println("For model ", PEP.Name, ": The ODEPE  max abs rel. err: ", besterror)
	end
end

function varied_estimation_main()
	print("testing")
	datasize = 21
	solver = Vern9()
	#solver = Rodas4P()
	time_interval = [-0.5, 0.5]
	for PEP in [
		global_unident_test(),
		vanderpol(),
		simple(),
		substr_test(),
		slowfast(),
		daisy_ex3_v4(),
		fitzhugh_nagumo(),
		lotka_volterra(),
		vanderpol(),
		daisy_mamil3(),
		sum_test(),
		hiv(),
		seir(),
		daisy_mamil4(),
		crauste(),
		daisy_ex3_v3(),
		daisy_ex3_v2(),
		treatment(),
		daisy_ex3(),
		hiv_local(), #no solutions found in old version?  check?
		biohydrogenation(),  #broken, debug
		sirsforced(),
	]
		analyze_parameter_estimation_problem(fillPEP(PEP), test_mode = true, showplot = false)
	end
end

varied_estimation_main()
# Write your tests here.

================
File: testdir/main_tests.jl
================
using ODEParameterEstimation
using Test
using ModelingToolkit
using HomotopyContinuation
using DifferentialEquations
using OrderedCollections
#using ParameterEstimation

#using Optimization
#using OptimizationOptimJL
#using NonlinearSolve\



function biohydrogenation()
	@parameters k5 k6 k7 k8 k9 k10
	@variables t x4(t) x5(t) x6(t) x7(t) y1(t) y2(t)
	D = Differential(t)
	states = [x4, x5, x6, x7]
	parameters = [k5, k6, k7, k8, k9, k10]

	@named model = ODESystem([
			D(x4) ~ -k5 * x4 / (k6 + x4),
			D(x5) ~ k5 * x4 / (k6 + x4) - k7 * x5 / (k8 + x5 + x6),
			D(x6) ~ k7 * x5 / (k8 + x5 + x6) - k9 * x6 * (k10 - x6) / k10,
			D(x7) ~ k9 * x6 * (k10 - x6) / k10,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x4,
		y2 ~ x5,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.143, 0.286, 0.429, 0.571, 0.714, 0.857]
	return ParameterEstimationProblem("BioHydrogenation",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 1)
end

function crauste()
	@parameters mu_N mu_EE mu_LE mu_LL mu_M mu_P mu_PE mu_PL delta_NE delta_EL delta_LM rho_E rho_P
	@variables t N(t) E(t) S(t) M(t) P(t) y1(t) y2(t) y3(t) y4(t)
	D = Differential(t)
	states = [N, E, S, M, P]
	parameters = [
		mu_N,
		mu_EE,
		mu_LE,
		mu_LL,
		mu_M,
		mu_P,
		mu_PE,
		mu_PL,
		delta_NE,
		delta_EL,
		delta_LM,
		rho_E,
		rho_P,
	]
	@named model = ODESystem(
		[
			D(N) ~ -N * mu_N - N * P * delta_NE,
			D(E) ~ N * P * delta_NE - E^2 * mu_EE -
				   E * delta_EL + E * P * rho_E,
			D(S) ~ S * delta_EL - S * delta_LM - S^2 * mu_LL -
				   E * S * mu_LE,
			D(M) ~ S * delta_LM - mu_M * M,
			D(P) ~ P^2 * rho_P - P * mu_P - E * P * mu_PE -
				   S * P * mu_PL,
		], t, states, parameters)
	measured_quantities = [y1 ~ N, y2 ~ E, y3 ~ S + M, y4 ~ P]

	ic = [0.167, 0.333, 0.5, 0.667, 0.833]
	p_true = [
		0.071,
		0.143,
		0.214,
		0.286,
		0.357,
		0.429,
		0.5,
		0.571,
		0.643,
		0.714,
		0.786,
		0.857,
		0.929,
	] # True Parameters

	return ParameterEstimationProblem("Crauste",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function daisy_ex3()
	@parameters p1 p3 p4 p6 p7
	@variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, u0]
	parameters = [p1, p3, p4, p6, p7]
	@named model = ODESystem([
			D(x1) ~ -1.0 * p1 * x1 + x2 + u0,
			D(x2) ~ p3 * x1 - p4 * x2 + x3,
			D(x3) ~ p6 * x1 - p7 * x3,
			D(u0) ~ 1.0,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ u0,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.167, 0.333, 0.5, 0.667, 0.833] # True Parameters


	return ParameterEstimationProblem("DAISY_ex3",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end



function daisy_ex3_v2()
	@parameters p1 p3 p4 p6 p7
	@variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, u0]
	parameters = [p1, p3, p4, p6, p7]
	@named model = ODESystem([
			D(x1) ~ -1.0 * p1 * x1 + x2 + u0,
			D(x2) ~ p3 * x1 - p4 * x2 + x3,
			D(x3) ~ p6 * x1 - p7 * x3,
			D(u0) ~ 1.0,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ u0,
	]
	ic = [1.0, 2.0, 1.0, 1.0]
	p_true = [0.2, 0.3, 0.5, 0.6, -0.2] # True Parameters

	return ParameterEstimationProblem("DAISY_ex3_v2",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end


function add_noise()
	@parameters a b c d
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t) y3(t)
	D = Differential(t)
	states = [x1, x2]
	parameters = [a, b, c, d]
	@named model = ODESystem([
			D(x1) ~ a * x1 + b * x2,
			D(x2) ~ c * x1 - d * x2], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2,
	]
	ic = [1.0, 2.0]
	p_true = [0.2, 0.3, 0.4, 0.5] # True Parameters

	return ParameterEstimationProblem("Noisy 2d linear",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end






function daisy_ex3_v3()
	@parameters p1 p3 p4 p6 p7 pd
	@variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, u0]
	parameters = [p1, p3, p4, p6, p7, pd]
	@named model = ODESystem([
			D(x1) ~ x2 + u0 - p1 * x1,
			D(x2) ~ p3 * x1 - p4 * x2 + x3,
			D(x3) ~ p6 * x1 - p7 * x3,
			D(u0) ~ pd,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ u0,
	]

	ic = [1.0, 2.0, 1.0, 1.0]
	p_true = [0.2, 0.3, 0.5, 0.6, -0.2, 1.0] # True Parameters

	return ParameterEstimationProblem("DAISY_ex3_v3",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end



function daisy_ex3_v4()
	@parameters p1 p3 p4 p6 p7 pd
	@variables t x1(t) x2(t) x3(t) u0(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, u0]
	parameters = [p1, p3, p4, p6, p7, pd]
	@named model = ODESystem([
			D(x1) ~ x2 + u0 - p1 * x1,
			D(x2) ~ p3 * x1 - p4 * x2 + x3,
			D(x3) ~ p6 * x1 - p7 * x3,
			D(u0) ~ pd,
		], t, states, parameters)
	measured_quantities = [y1 ~ x1 + x3, y2 ~ x2]


	ic = [1.0, 2.0, 1.0, 1.0]
	p_true = [0.2, 0.3, 0.5, 0.6, -0.2, 1.0] # True Parameters

	return ParameterEstimationProblem("DAISY_ex3_v4",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end






function daisy_mamil3(datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9())
	@parameters a12 a13 a21 a31 a01
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t)
	D = Differential(t)

	ic = [0.25, 0.5, 0.75]
	sampling_times = range(time_interval[1], time_interval[2], length = datasize)
	p_true = [0.167, 0.333, 0.5, 0.667, 0.833] # True Parameters

	states = [x1, x2, x3]
	parameters = [a12, a13, a21, a31, a01]
	@named model = ODESystem([D(x1) ~ -(a21 + a31 + a01) * x1 + a12 * x2 + a13 * x3,
			D(x2) ~ a21 * x1 - a12 * x2,
			D(x3) ~ a31 * x1 - a13 * x3],
		t, states, parameters)
	measured_quantities = [y1 ~ x1, y2 ~ x2]


	return ParameterEstimationProblem("DAISY_mamil3",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function daisy_mamil4(datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9())
	@parameters k01, k12, k13, k14, k21, k31, k41
	@variables t x1(t) x2(t) x3(t) x4(t) y1(t) y2(t) y3(t)
	D = Differential(t)

	ic = [0.2, 0.4, 0.6, 0.8]
	sampling_times = range(time_interval[1], time_interval[2], length = datasize)
	p_true = [0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875] # True Parameters

	states = [x1, x2, x3, x4]
	parameters = [k01, k12, k13, k14, k21, k31, k41]
	@named model = ODESystem([
			D(x1) ~ -k01 * x1 + k12 * x2 + k13 * x3 + k14 * x4 - k21 * x1 - k31 * x1 -
					k41 * x1,
			D(x2) ~ -k12 * x2 + k21 * x1,
			D(x3) ~ -k13 * x3 + k31 * x1,
			D(x4) ~ -k14 * x4 + k41 * x1],
		t, states, parameters)
	measured_quantities = [y1 ~ x1, y2 ~ x2, y3 ~ x3 + x4]


	return ParameterEstimationProblem("DAISY_mamil4",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function fitzhugh_nagumo()
	@parameters g a b
	@variables t V(t) R(t) y1(t) y2(t)
	D = Differential(t)
	states = [V, R]
	parameters = [g, a, b]

	ic = [0.333, 0.67]
	#sampling_times = range(time_interval[1], time_interval[2], length = datasize)
	p_true = [0.25, 0.5, 0.75] # True Parameters
	measured_quantities = [y1 ~ V]

	@named model = ODESystem([
			D(V) ~ g * (V - V^3 / 3 + R),
			D(R) ~ 1 / g * (V - a + b * R),
		], t, states, parameters)

	return ParameterEstimationProblem("fitzhugh-nagumo",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function hiv_local()
	@parameters b c d k1 k2 mu1 mu2 q1 q2 s
	@variables t x1(t) x2(t) x3(t) x4(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3, x4]
	parameters = [b, c, d, k1, k2, mu1, mu2, q1, q2, s]

	@named model = ODESystem([
			D(x1) ~ -b * x1 * x4 - d * x1 + s,
			D(x2) ~ b * q1 * x1 * x4 - k1 * x2 - mu1 * x2,
			D(x3) ~ b * q2 * x1 * x4 + k1 * x2 - mu2 * x3,
			D(x4) ~ -c * x4 + k2 * x3,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x4,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.091, 0.182, 0.273, 0.364, 0.455, 0.545, 0.636, 0.727, 0.818, 0.909]
	time_interval = [-0.5, 0.5]
	datasize = 20

	return ParameterEstimationProblem("hiv_local",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 7)
end

function hiv()
	@parameters lm d beta a k u c q b h
	@variables t x(t) y(t) v(t) w(t) z(t) y1(t) y2(t) y3(t) y4(t)
	D = Differential(t)
	states = [x, y, v, w, z]
	parameters = [lm, d, beta, a, k, u, c, q, b, h]

	@named model = ODESystem([
			D(x) ~ lm - d * x - beta * x * v,
			D(y) ~ beta * x * v - a * y,
			D(v) ~ k * y - u * v,
			D(w) ~ c * x * y * w - c * q * y * w - b * w,
			D(z) ~ c * q * y * w - h * z,
		], t, states, parameters)
	measured_quantities = [y1 ~ w, y2 ~ z, y3 ~ x, y4 ~ y + v]

	ic = [0.167, 0.333, 0.5, 0.667, 0.833]
	p_true = [0.091, 0.181, 0.273, 0.364, 0.455, 0.545, 0.636, 0.727, 0.818, 0.909]


	return ParameterEstimationProblem("hiv",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function lotka_volterra()
	@parameters k1 k2 k3
	@variables t r(t) w(t) y1(t)
	D = Differential(t)
	ic = [0.333, 0.667]
	p_true = [0.25, 0.5, 0.75] # True Parameters
	measured_quantities = [y1 ~ r]
	states = [r, w]
	parameters = [k1, k2, k3]

	@named model = ODESystem([
			D(r) ~ k1 * r - k2 * r * w,
			D(w) ~ k2 * r * w - k3 * w], t,
		states, parameters)

	return ParameterEstimationProblem("Lotka_Volterra", model, measured_quantities,
		:nothing, :nothing, p_true, ic, 0)
end

function seir()
	@parameters a b nu
	@variables t S(t) E(t) In(t) N(t) y1(t) y2(t)
	D = Differential(t)
	states = [S, E, In, N]
	parameters = [a, b, nu]

	@named model = ODESystem([
			D(S) ~ -b * S * In / N,
			D(E) ~ b * S * In / N - nu * E,
			D(In) ~ nu * E - a * In,
			D(N) ~ 0,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ In,
		y2 ~ N,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.25, 0.5, 0.75]

	return ParameterEstimationProblem("SEIR",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function simple()
	@parameters a b
	@variables t x1(t) x2(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2]
	parameters = [a, b]

	@named model = ODESystem([
			D(x1) ~ -a * x2,
			D(x2) ~ b * x1,  #edited from 1/b
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2]

	ic = [0.333, 0.667]
	p_true = [0.4, 0.8]

	return ParameterEstimationProblem("simple",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function sirsforced()
	@parameters b0 b1 g M mu nu
	@variables t i(t) r(t) s(t) x1(t) x2(t) y1(t) y2(t)
	D = Differential(t)
	states = [i, r, s, x1, x2]
	parameters = [b0, b1, g, M, mu, nu]

	@named model = ODESystem([
			D(i) ~ b0 * (1.0 + b1 * x1) * i * s - (nu + mu) * i,
			D(r) ~ nu * i - (mu + g) * r,
			D(s) ~ mu - mu * s - b0 * (1.0 + b1 * x1) * i * s + g * r,
			D(x1) ~ -M * x2,
			D(x2) ~ M * x1,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ i,
		y2 ~ r,
	]

	ic = [0.167, 0.333, 0.5, 0.667, 0.833]
	p_true = [0.143, 0.286, 0.429, 0.571, 0.714, 0.857]

	return ParameterEstimationProblem("sirsforced",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 3)
end

function slowfast()  # TODO(orebas):in the old code it was CVODE_BDF.  should we go back to that?
	#solver = CVODE_BDF()
	@parameters k1 k2 eB
	@variables t xA(t) xB(t) xC(t) eA(t) eC(t) y1(t) y2(t) y3(t) y4(t) eA(t) eC(t)
	D = Differential(t)
	states = [xA, xB, xC, eA, eC]
	parameters = [k1, k2, eB]
	@named model = ODESystem([
			D(xA) ~ -k1 * xA,
			D(xB) ~ k1 * xA - k2 * xB,
			D(xC) ~ k2 * xB,
			D(eA) ~ 0.0,
			D(eC) ~ 0.0,
		], t, states, parameters)

	measured_quantities = [y1 ~ xC, y2 ~ eA * xA + eB * xB + eC * xC, y3 ~ eA, y4 ~ eC]
	ic = [0.166, 0.333, 0.5, 0.666, 0.833]
	p_true = [0.25, 0.5, 0.75] # True Parameters

	return ParameterEstimationProblem("slowfast",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end

function slowfast2()  # TODO(orebas):in the old code it was CVODE_BDF.  should we go back to that?
	#solver = CVODE_BDF()
	@parameters k1 k2 eB eA eC
	@variables t xA(t) xB(t) xC(t) y1(t) y2(t) y3(t) y4(t)
	D = Differential(t)
	states = [xA, xB, xC]
	parameters = [k1, k2, eB, eA, eC]
	@named model = ODESystem([
			D(xA) ~ -k1 * xA,
			D(xB) ~ k1 * xA - k2 * xB,
			D(xC) ~ k2 * xB,
		], t, states, parameters)

	measured_quantities = [y1 ~ xC, y2 ~ eA * xA + eB * xB + eC * xC, y3 ~ eA * xC, y4 ~ eC * xC]
	ic = [0.166, 0.333, 0.5]
	p_true = [0.25, 0.5, 0.75, 0.666, 0.833] # True Parameters

	return ParameterEstimationProblem("slowfast2",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end




function substr_test()
	@parameters a b beta
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t) y3(t)
	D = Differential(t)
	states = [x1, x2, x3]
	parameters = [a, b, beta]

	@named model = ODESystem([
			D(x1) ~ -a * x2,
			D(x2) ~ b * (x1),
			D(x3) ~ a * b * beta * b * a * x3,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2,
		y3 ~ x3,
	]

	ic = [2.0, 3.0, 4.0]
	p_true = [0.1, 0.2, 0.3]

	return ParameterEstimationProblem("substr_test",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end


function global_unident_test()
	@parameters a b c d
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3]
	parameters = [a, b, c, d]

	@named model = ODESystem([
			D(x1) ~ -a * x1,
			D(x2) ~ (b + c) * (x1),
			D(x3) ~ d * x1,
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2,
	]

	ic = [2.0, 3.0, 4.0]
	p_true = [0.1, 0.2, 0.3, 0.4]

	return ParameterEstimationProblem("global_unident_test",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 4)

end


function sum_test()
	@parameters a b c d
	@variables t x1(t) x2(t) x3(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2, x3]
	parameters = [a, b, c]

	@named model = ODESystem([
			D(x1) ~ -a * x1,
			D(x2) ~ b * (x2),
			D(x3) ~ c * (x1 + x2),
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x3,
	]

	ic = [2.0, 3.0, 4.0]
	p_true = [0.1, 0.2, 0.3]

	return ParameterEstimationProblem("sum_test",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 3)

end





function treatment(datasize = 21, time_interval = [-0.5, 0.5], solver = Vern9())  #note the solver.  Vern9 apparently can't handle mass matrices
	@parameters a b d g nu
	@variables t In(t) N(t) S(t) Tr(t) y1(t) y2(t)
	D = Differential(t)
	states = [In, N, S, Tr]
	parameters = [a, b, d, g, nu]

	@named model = ODESystem([D(In) ~ b * S * In / N + d * b * S * Tr / N - (a + g) * In,
			D(N) ~ 0,
			D(S) ~ -b * S * In / N - d * b * S * Tr / N,
			D(Tr) ~ g * In - nu * Tr], t, states, parameters)
	measured_quantities = [
		y1 ~ Tr,
		y2 ~ N,
	]

	ic = [0.2, 0.4, 0.6, 0.8]
	p_true = [0.167, 0.333, 0.5, 0.667, 0.833]

	return ParameterEstimationProblem("treatment",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 6)
end

function vanderpol()
	@parameters a b
	@variables t x1(t) x2(t) y1(t) y2(t)
	D = Differential(t)
	states = [x1, x2]
	parameters = [a, b]

	@named model = ODESystem([
			D(x1) ~ a * x2,
			D(x2) ~ -(x1) - b * (x1^2 - 1) * (x2),
		], t, states, parameters)
	measured_quantities = [
		y1 ~ x1,
		y2 ~ x2,
	]

	ic = [0.333, 0.667]
	p_true = [0.4, 0.8]

	return ParameterEstimationProblem("vanderpol",
		model, measured_quantities, :nothing, :nothing, p_true, ic, 0)
end


function varied_estimation_main()
	#solver = AutoVern9(Rodas5())
	solver = Vern9()
	#solver = Rodas4P()

	time_interval = [-0.5, 0.5]
	datasize = 21

	for PEP in [
		#simple(),
		#lotka_volterra(),
		#slowfast2(),
		#biohydrogenation(),
		#add_noise(),

		simple(),
		substr_test(),
		#add_noise()

		vanderpol(),
		daisy_mamil3(),
		fitzhugh_nagumo(),
		slowfast(),
		slowfast2(),
		daisy_ex3_v3(),
		daisy_ex3_v2(),
		daisy_ex3_v4(),
		sum_test(),
		daisy_mamil4(),
		lotka_volterra(),
		global_unident_test(),
		daisy_ex3(),
		hiv(),
		seir(),
		hiv_local(),
		biohydrogenation(),
		treatment(),
		crauste(),  #these seem to be the slowest
		sirsforced(), #these seem to be the slowest 
	]
		analyze_parameter_estimation_problem(fillPEP(PEP, datasize = datasize, time_interval = time_interval), test_mode = false, showplot = true)
	end
end

varied_estimation_main()
# Write your tests here.

================
File: .github/workflows/CI.yml
================
name: CI
on:
  push:
    branches:
      - main
    tags: ['*']
  pull_request:
  workflow_dispatch:
concurrency:
  # Skip intermediate builds: always.
  # Cancel intermediate builds: only if it is a pull request build.
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ startsWith(github.ref, 'refs/pull/') }}
jobs:
  test:
    name: Julia ${{ matrix.version }} - ${{ matrix.os }} - ${{ matrix.arch }} - ${{ github.event_name }}
    runs-on: ${{ matrix.os }}
    timeout-minutes: 60
    permissions: # needed to allow julia-actions/cache to proactively delete old caches that it has created
      actions: write
      contents: read
    strategy:
      fail-fast: false
      matrix:
        version:
          - '1.10'
          - 'nightly'
        os:
          - ubuntu-latest
        arch:
          - x64
    steps:
      - uses: actions/checkout@v4
      - uses: julia-actions/setup-julia@v2
        with:
          version: ${{ matrix.version }}
          arch: ${{ matrix.arch }}
      - uses: julia-actions/cache@v2
      - uses: julia-actions/julia-buildpkg@v1
      - uses: julia-actions/julia-runtest@v1

================
File: .github/workflows/CompatHelper.yml
================
name: CompatHelper
on:
  schedule:
    - cron: 0 0 * * *
  workflow_dispatch:
jobs:
  CompatHelper:
    runs-on: ubuntu-latest
    steps:
      - name: Pkg.add("CompatHelper")
        run: julia -e 'using Pkg; Pkg.add("CompatHelper")'
      - name: CompatHelper.main()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMPATHELPER_PRIV: ${{ secrets.DOCUMENTER_KEY }}
        run: julia -e 'using CompatHelper; CompatHelper.main()'

================
File: .github/workflows/TagBot.yml
================
name: TagBot
on:
  issue_comment:
    types:
      - created
  workflow_dispatch:
    inputs:
      lookback:
        default: "3"
permissions:
  actions: read
  checks: read
  contents: write
  deployments: read
  issues: read
  discussions: read
  packages: read
  pages: read
  pull-requests: read
  repository-projects: read
  security-events: read
  statuses: read
jobs:
  TagBot:
    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'
    runs-on: ubuntu-latest
    steps:
      - uses: JuliaRegistries/TagBot@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ssh: ${{ secrets.DOCUMENTER_KEY }}

================
File: docs/src/index.md
================
```@meta
CurrentModule = ODEParameterEstimation
```

# ODEParameterEstimation

Documentation for [ODEParameterEstimation](https://github.com/orebas/ODEParameterEstimation.jl).

```@index
```

```@autodocs
Modules = [ODEParameterEstimation]
```

================
File: testdir/1000x/1000x.jl
================
#using ParameterEstimation
using ModelingToolkit, DifferentialEquations
using ODEParameterEstimation
solver = Vern9()
@parameters K1 g1 K2 g2 pi
@variables t S0(t) S1(t) S2(t) y0(t) y1(t) y2(t)
D = Differential(t)
states = [S0, S1, S2]
parameters = [K1, g1, K2, g2, pi]
@named model = ODESystem([
		D(S0) ~ -K1 * S0 / (g1 * S0 + g2 * S1 + 1),
		D(S1) ~ (-K2 * S1 + (1 - pi) * K1 * S0) / (g1 * S0 + g2 * S1 + 1),
		D(S2) ~ (pi * K1 * S0 + K2 * S1) / (g1 * S0 + g2 * S1 + 1),
	], t, states, parameters)
measured_quantities = [y0 ~ S0, y1 ~ S1, y2 ~ S2]
ic = [5.0, 0.0, 0.0]
time_interval = [0.0, 20.0]
datasize = 8
time_points = [0, 0.5, 2, 3.25, 3.75, 5, 10, 20]
grid_num = 4
for i1 in 1:grid_num
	for i2 in 1:grid_num
		for i3 in 1:grid_num
			for i4 in 1:grid_num
				for i5 in 1:grid_num
					p_true = [0.01 + (i1 - 1) / grid_num, 0.01 + (i2 - 1) / grid_num, 0.01 + (i3 - 1) / grid_num, 0.01 + (i4 - 1) / grid_num, 0.01 + (i5 - 1) / grid_num]
					data_sample = sample_data(
						model, measured_quantities, time_interval, p_true,
						ic, datasize; solver = solver, uneven_sampling = true,
						uneven_sampling_times = time_points)

					res = ODEPEtestwrapper(model, measured_quantities,
						data_sample, solver, max_num_points = 11) #at_time = 0.01, 


					println("$i1, $i2, $i3, $i4, $i5")
					println("the results are:")
					display(res)
					for each in res
						estimates = collect(values(each.parameters))
						println("Relative mean square error for parameters: ",
							sqrt(sum([p^2 for p in (p_true - estimates) ./ p_true]) / length(p_true)) * 100, "%")
					end
				end
			end
		end
	end
end
